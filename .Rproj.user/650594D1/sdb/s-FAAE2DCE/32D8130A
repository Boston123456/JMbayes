{
    "contents" : "\n# Required libraries that I need to load to run the script\n# ========================================================\nlapply(c(\"data.table\", \"survival\", \"nlme\", \"JMbayes\", \"lme4\"), require, character.only=T)\n\n\n# ******************************************************************************************************\n# ******************************************************************************************************\n# **************************   ISSUE 1: LEFT-TRUNCATED SURVIVAL DATA   *********************************\n# ******************************************************************************************************\n# ******************************************************************************************************\n\n# Left truncation occurs because the policyholders can be detected only until after they are at risk \n# (age > 65 years). We are going to considerate left-truncated data with age as time scale, that is, \n# policyholders are included in the study if they belonged to the health insurance at the date that the\n# study started and if they have reached the age 65 at the entry time, that is, if their survival time \n# exceeded that age. \n\n# # Longitudinal dataset with 3000 id considering left-truncation\n# ---------------------------------------------------------------\ntr.d3000  # 17400 rows\n\n# Survival dataset with 3000 ids considering left-truncation\n# ----------------------------------------------------------\ntr.d3000.id # 3000 rows\n\n# Graphical comparison between the survival curve for a policyholder older than 65 considering \n# left-truncation and the same estimate if the left-truncation were not considered.\n# ---------------------------------------------------------------------------------------------\n \n# Data without considering truncation:\nnt.d3000.id <- tr.d3000.id[, list(id, start=0, stop, cens)]\n\n# Comparison plot of survival curves for an elderly 65 policyholder when left.truncation  \n# is considered at the age of 65 and when it is not considered\n# ---------------------------------------------------------------------------------------\nwindows(height=5, width=7.5)\npar(mar=c(5,5,3,2), cex.main=0.9, cex.axis=0.9,cex.lab=0.9,las=1)\nplot(survfit(Surv(start, stop, cens)~1, data=tr.d3000.id), xlab=\"Age (yr)\",\n\tylab=expression(paste(\"Estimator \",hat(S),\"(t |T> 65) \")), \n\tfirstx=0, xlim=c(0,40), xaxt=\"n\", mark.time=F, lwd=2, conf.int=F)\nlines(survfit(Surv(start, stop, cens)~1,data=nt.d3000.id),\n\t\tcol=2, lty=2, lwd=2, mark.time=F,conf.int=F)\naxis(1,at=seq(0,40,5),labels=seq(65,105,5))\naxis(2,at=seq(0,1.1,0.1))\ntitle(\"Survival estimate for 65+ with truncation vs. not truncation\")\nlegend('topright', c(\"Truncation\",\"Not truncation\"),cex=0.9, inset=0.01, \n\t\tseg.len=3.5, bg='cornsilk', lwd=2, col=1:2, lty=1:2)\n\n# It is observed that not taking into account left-truncation issue at 65 yeras leads \"artificially\" to\n# higher expected survival times. The former result is logical becuause not considering this phenomenon \n# would entail that all policyholders enter the study at the age of 65 yr, and consequently increases the\n# follow-up time within study on each individual (increases the time-interval contribution for those \n# policyholders who really didn't enter at 65, but after.\n\n\n# *******************************************************************************************************\n# *******************************************************************************************************\n# *****************   ISSUE 2: BASIC JM CONSIDERING CONTINUOUS VARIABLE log(1+claimyr)  *****************\n# *******************************************************************************************************\n# *******************************************************************************************************\n\n# Linear mixed model with random intercept (PACKAGE nlme)\n# -------------------------------------------------------\ntr.glmmFit.int <- lme(log(1+claimyr) ~ obstime, random = ~ 1 | id, data = tr.d3000)\n\n\n# Survival model\n# --------------\ntr.Cox.id <- coxph(Surv(start, stop, cens) ~ sex + cluster(id), data=tr.d3000.id, x=TRUE, model=TRUE)\n\n\n# Basic Joint Model\n# -----------------\ntr.JMb.int <- jointModelBayes(tr.glmmFit.int, tr.Cox.id, timeVar = \"obstime\",  n.iter=30000)\n\n# Variance Components:\n#               StdDev\n#(Intercept) 0.2344958\n#Residual    0.3316529\n\n#Longitudinal Process\n#             Value Std.Err Std.Dev   2.5%  97.5%      P\n#(Intercept) 0.1054   2e-04  0.0056 0.0948 0.1164 <0.001\n#obstime     0.0043   0e+00  0.0003 0.0037 0.0050 <0.001\n\n#Event Process\n#          Value Std.Err  Std.Dev    2.5%     97.5%      P\n#sex1     0.1077  0.0072   0.1428 -0.1563    0.3978  0.463\n#Assoct   2.4596  0.0162   0.3068  1.8269    3.0414 <0.001\n\n# plot(tr.JMb.int) # IT WORKS!!\n\nplot(jointFit.pbc1, param = c(\"betas\", \"sigma\", \"alphas\", \"gammas\"))\n# *******************************************************************************************************\n# *******************************************************************************************************\n# *********************  ISSUE 3: JM CONSIDERING POISSON VARIABLE log{E(claimyr)}    ********************\n# *******************************************************************************************************\n# *******************************************************************************************************\n\n# =========================================\n# JOINT MODEL POISSON WITH RANDOM INTERCEPT\n# =========================================\n\n# Longitudinal Poisson model with random intercept (PACKAGE lme4)\n# ---------------------------------------------------------------\ntr.glmm.Pois.int <- glmer(claimyr ~ obstime + (1|id), nAGQ=15, control=glmerControl(optimizer=\"bobyqa\"),\n\t\t\t\tfamily = poisson(),data = tr.d3000) \n# summary(tr.glmm.Pois.int)\n\n# How can I test for overdispersion/compute an overdispersion factor?\n# -------------------------------------------------------------------\n# http://glmm.wikidot.com/faq\n\noverdisp_fun <- function(model) {\n  # number of variance parameters in an n-by-n variance-covariance matrix\n  vpars <- function(m) {\n    nrow(m)*(nrow(m)+1)/2\n  }\n  model.df <- sum(sapply(VarCorr(model),vpars))+length(fixef(model))\n  rdf <- nrow(model.frame(model))-model.df\n  rp <- residuals(model,type=\"pearson\")\n  Pearson.chisq <- sum(rp^2)\n  prat <- Pearson.chisq/rdf\n  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)\n  c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)\n}\n\noverdisp_fun(tr.glmm.Pois.int)\n#        chisq        ratio          rdf            p \n# 1.564072e+04 8.840558e-01 1.769200e+04 1.000000e+00 \n\n\n# Longitudinal Poisson model with random intercept \n# ------------------------------------------------\ntr.glmmFit.Pois.int <- glmmPQL(claimyr ~ obstime, \n\t\t\t\t random = ~ 1|id, family = poisson(), niter = 100, data = tr.d3000) \n\n# Random effects:\n#          (Intercept)  Residual\n# StdDev:     1.156777 0.9563513\n\n# Fixed effects:\n#                   Value  Std.Error  p-value\n# (Intercept)  -2.1174317 0.04414963        0\n# obstime       0.0341812 0.00254769        0\n\n\n# Survival model\n# --------------\ntr.Cox.id <- coxph(Surv(start, stop, cens) ~ sex + cluster(id), data=tr.d3000.id, x=TRUE, model=TRUE)\n\n\n# POISSON Joint Model with random intercept\n# -----------------------------------------\ndLongPois <- function (y, eta.y, scale, log=FALSE, data) {\n dpois(x=y, lambda=exp(eta.y), log=log)\n }\n\ntr.JMb.Pois.int <- jointModelBayes(tr.glmmFit.Pois.int, tr.Cox.id,\n\t\t\ttimeVar=\"obstime\", densLong = dLongPois, n.iter=50000)  # time: 53 minutes\n\n# Variance Components:\n#              StdDev\n#(Intercept) 1.170645\n\n# Longitudinal Process\n#               Value Std.Err Std.Dev    2.5%   97.5%      P\n# (Intercept) -2.1675   9e-04   0.030 -2.2266 -2.1074 <0.001\n# obstime      0.0243   1e-04   0.002  0.0204  0.0281 <0.001\n\n# Event Process\n#           Value Std.Err  Std.Dev    2.5%    97.5%      P\n# sex1     0.1164  0.0058   0.1363 -0.1534    0.3803  0.395\n# Assoct   0.5059  0.0034   0.0810  0.3461    0.6657 <0.001\n\n# plot(tr.JMb.Pois.int) \t\t\t\t\t\t### IT WORKS !!! ###\n\n\n# List of 3000 random intercepts: b0_i.JM.Pois.int ~ N(0, 1.170645) , i=1,...,3000\n# --------------------------------------------------------------------------------\nb0_i.JM.Pois.int <- ranef(tr.JMb.Pois.int)\t\n\n# # List of 17400 linear predictors\n# ---------------------------------\t\netay_i.JM.Pois.int <- fitted(tr.JMb.Pois.int)\n\n# List of 17400 expected values: mu_i.Pois.int(t_ij) = exp{etay_i.Pois.int(t_ij)}\n# -------------------------------------------------------------------------------\t\t\nmu_i.JM.Pois.int <- exp(fitted(tr.JMb.Pois.int))\t\n\n\n# =====================================================\n# JOINT MODEL POISSON RANDOM INTERCEPT AND RANDOM SLOPE\n# =====================================================\n\n# Longitudinal Poisson model with random intercept+slope\n# ------------------------------------------------------\ntr.glmmFit.Pois.slp <- glmmPQL(claimyr ~ obstime, random = ~ obstime|id, family = poisson(),\n\t\t\t\tcontrol=lmeControl(opt='optim'), niter = 30, data = tr.d3000) \n\n# ERROR MESSAGE:\n# Error in solve.default(pdMatrix(a, factor = TRUE)) : \n#  Lapack routine dgesv: system is exactly singular: U[1,1] = 0\n\n## IT DOES NOT CONVERGE: POSSIBLE OVERFITTING !!\n\n\n# ******************************************************************************************************\n# ******************************************************************************************************\n# ***************   ISSUE 4: COMPARISON ON DIFFERENT ASSOCIATION STRUCTURES   **************************\n# ******************************************************************************************************\n# ******************************************************************************************************\n\n# ===================================================\n# FIRST CASE: BASIC JOINT MODEL WITH RANDON INTERCEPT\n# ===================================================\n\n### Current value of log(1+claimyr) (already done)\n### ==============================================\ntr.JMb.NB.int.CURRENT <- jointModelBayes(tr.glmmFit.int, tr.Cox.id,\n\t\t\ttimeVar=\"obstime\", n.iter=30000)\t## time: 35.7 min\n\n#  Variance Components:\n#                StdDev\n# (Intercept) 0.2344958\n# Residual    0.3316529\n\n# Longitudinal Process\n#               Value Std.Err Std.Dev    2.5%   97.5%      P\n# (Intercept)  0.1054   2e-04  0.0056 0.0948  0.1164  <0.001\n# obstime      0.0043   0e+00  0.0003 0.0037  0.0050  <0.001\n\n# Event Process\n#           Value Std.Err  Std.Dev    2.5%     97.5%      P\n# sex1     0.1077  0.0072   0.1428 -0.1563    0.3978  0.463\n# Assoct   2.4596  0.0162   0.3068  1.8269    3.0414 <0.001\n\n\n## Slope value in BASIC JM of log(1+claimyr)\n## ========================================\ndForm <- list(fixed = ~ 1, indFixed = 2, random = ~0, indRandom = FALSE)\n\ntr.JMb.int.TREND <- jointModelBayes(tr.glmmFit.int, tr.Cox.id, timeVar=\"obstime\", \n\t\t\t\tparam = \"td-both\", extraForm = dForm) \n\t\t\t\tverbose = TRUE, n.iter=200) \t\t# time: min\n\n# ERROR MESSAGE\n#  |     0%Error in Zb[indRE.id] <- lP.RE$Zb[indRE.id] : \n#  NAs are not allowed\n\n\n## Cumulative value in BASIC JM of log(1+claimyr)\n## ==============================================\niForm <- list(fixed = ~ -1 + obstime + I(obstime^2/2), indFixed = 1:2, \n\t\t\trandom = ~ -1 +  obstime, indRandom = 1)\n\ntr.JMb.int.CUM <- jointModelBayes(tr.glmmFit.int, tr.Cox.id, timeVar=\"obstime\", \n\t\t\t\tparam = \"td-extra\", extraForm = iForm, n.iter=30000) \t\t\n\n# ERROR MESSAGE:\n# |   0%Error in  if (lRatio.gammas>=0 || runif(1L) < exp(lRatio.gammas)){\n# missing value where TRUE/FALSE is necessary\n\n\n## Weighted cumulative value in BASIC JM of log(1+claimyr)\n## =======================================================\n\n# FIRST ATTEMPT\n# -------------\nWF1 <- function (u, parms, max.time) {\n    dexp(x = u, lambda = parms)\n}\n\ntr.JMb.int.WF1 <- jointModelBayes(tr.glmmFit.int, tr.Cox.id, timeVar = \"obstime\", \n                                  estimateWeightFun = TRUE, weightFun = WF1, \n                                  priorShapes = list(shape1 = dunif), \n                                  priors = list(priorshape1 = c(0, 10)), verbose2 = TRUE)\n\n# ERROR MESSAGE:\n# Error in weightFun(u.idGK, shapes, max.time) : unused argument (max.time)\n\n\n# SECOND ATTEMPT\n# --------------\nWF2 <- function (u, parms) {\n num <- dexp(x = u, lambda = parms, t.max)\n den <- pexp(q=c(0,t.max), sd=parms)\n num/(den[2L]-den[1L])\n }\n\n# ERROR MESSAGE:\ntr.JMb.int.WF2 <- jointModelBayes(tr.glmmFit.int, tr.Cox.id, \n\t\t\ttimeVar=\"obstime\", \n\t\t\testimateWeightFun = TRUE,\n\t\t\tweightFun = WF2,\n\t\t\tpriorShapes = list(shape1 = dunif),\n\t\t\tpriors = list(priorshape1 = c(0, 10)))\n\n# ERROR MESSAGE:\n# Error in weightFun(u.idGK, shapes, max.time) : unused argument (max.time)\n\n\n\n# *******************************************************************************************************\n# *******************************************************************************************************\n# *****************   ISSUE 5: TRANSFORMATION TO WORK IN TERMS OF NUMBER OF CLAIMS    *******************\n# *******************************************************************************************************\n# *******************************************************************************************************\n\n# =================================\n# WORKING WITH THE NUMBER OF CLAIMS \n# =================================\n\n# ATTEMPT 1\n# ---------\ntf <- function (x, data) {exp(x)}\n\ntr.JMb.Pois.int.transf <- update(tr.JMb.Pois.int, transFun = list(\"value\" = tf)) \n\n# ERROR MESSAGE:\n# 0%Error in if (lRatio.gammas >= 0 || runif(1L) < exp(lRatio.gammas)) { : \n#  missing value where TRUE/FALSE is necessary\n\n\n# ATTEMPT 2\n# ---------\ntf <- function (x, data) {exp(x)/100}\n\ntr.JMb.Pois.int.transf <- update(tr.JMb.Pois.int, transFun = list(\"value\" = tf)) \n\n# ERROR MESSAGE:\n#0%Error in if (lRatio.alphas >= 0 || runif(1L) < exp(lRatio.alphas)) { : \n#  missing value where TRUE/FALSE is necessary\n\n\n# ===========================================================================\n# WORKING WITH THE INTERACTION BETWEEN THE LINEAR PREDICTOR AND SEX COVARIATE\n# ===========================================================================\n\ntf2 <- function (x, data) {\n\tcbind(x, \"sex1\" = x * (data$sex == \"1\"))\n\t}\ntr.JMb.Pois.int.transf2 <- update(tr.JMb.Pois.int, transFun = list(\"value\" = tf2)) \nsummary(tr.JMb.Pois.int.transf2)\n\n\n\n\n\n\n",
    "created" : 1442818216296.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "155|58|157|1|\n",
    "hash" : "3416691965",
    "id" : "32D8130A",
    "lastKnownWriteTime" : 1442818746,
    "path" : "C:/Users/drizopoulos/Desktop/Report_1_150916.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}