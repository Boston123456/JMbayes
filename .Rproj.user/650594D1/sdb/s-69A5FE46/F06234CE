{
    "contents" : "jointModelBayes <- function (lmeObject, survObject, timeVar, survMod = c(\"weibull-PH\", \"spline-PH\"), \n        param = c(\"td-value\", \"td-extra\", \"td-both\", \"shared-RE\"), robust = FALSE, robust.b = FALSE, \n        df = 4, df.b = 4, lag = 0, init = NULL, extraForm = NULL, priors = NULL, control = list(), ...) {\n    cl <- match.call()\n    if (!inherits(lmeObject, \"lme\"))\n        stop(\"\\n'lmeObject' must inherit from class lme.\")\n    if (length(lmeObject$group) > 1)\n        stop(\"\\nnested random-effects are not allowed in lme().\")\n    if (!is.null(lmeObject$modelStruct$corStruct))\n        warning(\"correlation structure in 'lmeObject' is ignored.\\n\")\n    if (!is.null(lmeObject$modelStruct$varStruct))\n        warning(\"variance structure in 'lmeObject' is ignored.\\n\")        \n    if (!inherits(survObject, \"coxph\") && !inherits(survObject, \"survreg\"))\n        stop(\"\\n'survObject' must inherit from class coxph or class survreg.\")\n    if (is.null(survObject$x))\n        stop(\"\\nuse argument 'x = TRUE' in \", if (inherits(survObject, \"coxph\")) \"'coxph()'.\" else \"'survreg()'.\")\n    if (length(timeVar) != 1 || !is.character(timeVar))\n        stop(\"\\n'timeVar' must be a character string.\")\n    if (param %in% c(\"td-extra\", \"td-both\") && is.null(extraForm)) {\n        stop(\"\\nwhen parameterization is 'td-extra' or 'td-both' you need to specify the 'extraForm' argument.\")\n    }\n    if (!param %in% c(\"td-extra\", \"td-both\") && !is.null(extraForm)) {\n        stop(\"\\nyou have defined 'extraForm' but the parameterization is neither 'td-extra' nor 'td-both'.\")\n    }    \n    if (param %in% c(\"td-extra\", \"td-both\") && !is.list(extraForm)) {\n        stop(\"\\nthe 'extraForm' argument must be a list with components 'fixed' (a formula),\\n\\t'indFixed'\", \n            \"(a numeric vector), 'random' (a formula) and 'indRandom' (a numeric vector).\")\n    }\n    survMod <- match.arg(survMod)\n    param <- match.arg(param)\n    # extract response & design matrix survival process\n    formT <- formula(survObject)\n    if (inherits(survObject, \"coxph\")) {\n        W <- survObject$x\n        Time <- survObject$y[, 1]\n    } else {\n        W <- survObject$x[, -1, drop = FALSE]\n        Time <- exp(survObject$y[, 1])\n    }\n    nT <- length(Time)\n    if (!length(W))\n        W <- NULL\n    event <- survObject$y[, 2]\n    zeros <- numeric(nT) # for the zeros trick\n    # longitudinal process\n    id <- as.vector(unclass(lmeObject$groups[[1]]))\n    b <- data.matrix(ranef(lmeObject))\n    one.RE <- ncol(b) == 1\n    if (one.RE)\n        b <- cbind(b, rep(0, nrow(b)))\n    dimnames(b) <- NULL\n    nY <- nrow(b)\n    if (nY != nT)\n        stop(\"sample sizes in the longitudinal and event processes differ.\\n\")\n    TermsX <- lmeObject$terms\n    data <- lmeObject$data[all.vars(TermsX)]\n    data <- data[complete.cases(data), ]\n    formYx <- formula(lmeObject)\n    mfX <- model.frame(TermsX, data = data)\n    X <- model.matrix(formYx, mfX)\n    formYz <- formula(lmeObject$modelStruct$reStruct[[1]])    \n    mfZ <- model.frame(terms(formYz), data = data)\n    TermsZ <- attr(mfZ, \"terms\")\n    Z <- model.matrix(formYz, mfZ)\n    if (one.RE)\n        Z <- cbind(Z, rep(0, nrow(Z)))\n    y.long <- model.response(mfX, \"numeric\")\n    offset <- as.vector(c(1, 1 + cumsum(tapply(id, id, length))))\n    # control values\n    con <- list(program = \"JAGS\", n.chains = 1, n.iter = 10000, n.burnin = 5000, \n        n.thin = 1, n.adapt = 1000, K = 100, C = 5000, working.directory = getwd(), \n        bugs.directory = \"C:/Program Files/WinBUGS14/\", openbugs.directory = NULL, \n        clearWD = TRUE, over.relax = TRUE, knots = NULL, ObsTimes.knots = TRUE, \n        lng.in.kn = 5, ordSpline = 4, bugs.seed = 1, quiet = FALSE)\n    control <- c(control, list(...))\n    namC <- names(con)\n    con[(namc <- names(control))] <- control\n    if (length(noNms <- namc[!namc %in% namC]) > 0) \n        warning(\"unknown names in control: \", paste(noNms, collapse = \", \"))\n    data.id <- data[!duplicated(id), ]\n    if (!timeVar %in% names(data))\n        stop(\"\\n'timeVar' does not correspond to one of the columns in the model.frame of 'lmeObject'.\")\n    # extra design matrices for the longitudinal part\n    data.id[[timeVar]] <- pmax(Time - lag, 0)\n    if (param %in% c(\"td-value\", \"td-both\")) {\n        mfX.id <- model.frame(TermsX, data = data.id)\n        mfZ.id <- model.frame(TermsZ, data = data.id)\n        Xtime <- model.matrix(formYx, mfX.id)\n        Ztime <- model.matrix(formYz, mfZ.id)\n        if (one.RE)\n            Ztime <- cbind(Ztime, rep(0, nrow(Ztime)))\n        long <- c(X %*% fixef(lmeObject)) + rowSums(Z * b[id, ])\n    }\n    if (param %in% c(\"td-extra\", \"td-both\")) {\n        mfX.deriv <- model.frame(terms(extraForm$fixed), data = data)\n        TermsX.deriv <- attr(mfX.deriv, \"terms\")\n        mfZ.deriv <- model.frame(terms(extraForm$random), data = data)\n        TermsZ.deriv <- attr(mfZ.deriv, \"terms\")\n        mfX.deriv.id <- model.frame(TermsX.deriv, data = data.id)\n        mfZ.deriv.id <- model.frame(TermsZ.deriv, data = data.id)      \n        Xtime.deriv <- model.matrix(extraForm$fixed, mfX.deriv.id)\n        Ztime.deriv <- model.matrix(extraForm$random, mfZ.deriv.id)\n        Xderiv <- model.matrix(extraForm$fixed, mfX.deriv)\n        Zderiv <- model.matrix(extraForm$random, mfZ.deriv)\n        long.deriv <- as.vector(c(Xderiv %*% fixef(lmeObject)[extraForm$indFixed]) + \n            if (length(extraForm$indRandom) > 1 || extraForm$indRandom) \n                rowSums(Zderiv * b[id, extraForm$indRandom, drop = FALSE])\n            else\n                rep(0, nrow(Zderiv)))\n    }\n    if (param == \"td-value\")\n        long.deriv <- NULL\n    if (param == \"td-extra\")\n        long <- NULL\n    # response vectors and design matrices\n    y <- list(y = y.long, offset = offset, logT = log(Time), event = event, zeros = zeros, lag = lag)\n    x <- list(X = X, Z = Z, \n        W = if (survMod == \"weibull-PH\") { \n            if (is.null(W)) cbind(rep(1, nT), rep(0, nT)) else cbind(1, W)\n        } else {\n            if (is.null(W)) cbind(rep(0, nT), rep(0, nT)) else {\n                if (ncol(W) == 1) cbind(W, rep(0, nT)) else W\n            }\n    })\n    x <- switch(param, \n        \"td-value\" = c(x, list(Xtime = Xtime, Ztime = Ztime)),\n        \"td-extra\" = c(x, list(Xtime.deriv = Xtime.deriv, Ztime.deriv = Ztime.deriv)),\n        \"td-both\" = c(x, list(Xtime = Xtime, Ztime = Ztime, \n            Xtime.deriv = Xtime.deriv, Ztime.deriv = Ztime.deriv)),\n        \"shared-RE\" = x)\n    wk <- gaussKronrod()$wk\n    sk <- gaussKronrod()$sk\n    K <- length(sk)\n    P <- Time/2\n    st <- outer(P, sk + 1)\n    id.GK <- rep(seq_along(Time), each = K)\n    data.id2 <- data.id[id.GK, ]\n    data.id2[[timeVar]] <- c(t(st))\n    x <- c(x, list(P = P, st = st, wk = wk))    \n    if (param %in% c(\"td-value\", \"td-both\")) {\n        mfX <- model.frame(TermsX, data = data.id2)\n        mfZ <- model.frame(TermsZ, data = data.id2)\n        Xs <- model.matrix(formYx, mfX)\n        Zs <- model.matrix(formYz, mfZ)\n        if (one.RE)\n            Zs <- cbind(Zs, rep(0, nrow(Zs)))\n        x <- c(x, list(Xs = Xs, Zs = Zs))\n    }\n    if (param %in% c(\"td-extra\", \"td-both\")) {\n        mfX.deriv <- model.frame(TermsX.deriv, data = data.id2)\n        mfZ.deriv <- model.frame(TermsZ.deriv, data = data.id2)\n        Xs.deriv <- model.matrix(extraForm$fixed, mfX.deriv)\n        Zs.deriv <- model.matrix(extraForm$random, mfZ.deriv)\n        x <- c(x, list(Xs.deriv = Xs.deriv, Zs.deriv = Zs.deriv))\n    }\n    evTime <- cens <- Time\n    cens[event == 1] <- 0\n    evTime[event == 0] <- NA\n    y <- c(y, list(evTime = evTime, censTime = cens))    \n    # extra design matrices for the log approximated baseline hazard\n    if (survMod == \"spline-PH\") { \n        kn <- if (is.null(con$knots)) {\n            pp <- seq(0, 1, length.out = con$lng.in.kn + 2)\n            pp <- tail(head(pp, -1), -1)\n            tt <- if (con$ObsTimes.knots) Time else Time[event == 1]\n            quantile(tt, pp, names = FALSE)\n        } else {\n            con$knots\n        }\n        kn <- kn[kn < max(Time)]\n        rr <- sort(c(rep(range(Time, st), con$ordSpline), kn))\n        con$knots <- rr\n        W2 <- splineDesign(rr, Time, ord = con$ordSpline)\n        if (any(colSums(W2) == 0))\n            stop(\"\\nsome of the knots of the B-splines basis are set outside the range\",\n                \"\\n   of the observed event times for one of the strata; refit the model\", \n                \"\\n   setting the control argument 'equal.strata.knots' to FALSE.\")\n        W2s <- splineDesign(rr, c(t(st)), ord = con$ordSpline)\n        x <- c(x, list(W2 = W2, W2s = W2s))\n    }\n    # default priors\n    ncX <- ncol(X)\n    ncZ <- ncol(Z)\n    ncW <- ncol(x$W)\n    ncW2 <- ncol(x$W2)\n    betas <- rep(0, ncX)\n    var.betas <- rep(con$K, ncX)\n    sigma2 <- lmeObject$sigma^2\n    VC <- lapply(pdMatrix(lmeObject$modelStruct$reStruct), \"*\", \n        lmeObject$sigma^2)[[1]]\n    if (one.RE)\n        VC <- cbind(c(VC, 0), c(0, 1))\n    inv.VC <- solve(VC)\n    alphas <- Dalphas <- 0\n    var.alphas <- var.Dalphas <- con$K\n    gammas <- rep(0, ncW)\n    var.gammas <- rep(con$K, ncW)\n    if (survMod == \"weibull-PH\") {\n        if (is.null(W)) var.gammas[2] <- 1e-05\n    } else {\n        if (is.null(W)) var.gammas[1:2] <- 1e-05\n        if (!is.null(W) && ncol(W) == 1) var.gammas[2] <- 1e-05\n        Bs.gammas <- rep(0, ncW2)\n        var.Bs.gammas <- rep(con$K/10, ncW2)\n    }\n    # Data to be passed to WinBUGS\n    Data <- list(N = nY, df = df, df.b = df.b, C = con$C, K = K, R = con$R, ncX = ncX, \n        ncZ = ncZ, ncW = ncW, ncW2 = ncW2,\n        priorMean.betas = betas, priorTau.betas = diag(1 / var.betas),\n        priorA.tau = (1/sigma2)^2 / 10, priorB.tau = (1/sigma2) / 10,\n        priorMean.gammas = gammas, priorTau.gammas = diag(1 / var.gammas),\n        priorMean.alphas = alphas, priorTau.alphas = 1 / var.alphas,\n        priorMean.Dalphas = alphas, priorTau.Dalphas = 1 / var.Dalphas,\n        priorA.sigma.t = 10, priorB.sigma.t = 10, priorA.rho = 2, priorB.rho = 1,\n        nb = ncZ, mu0 = rep(0, ncZ), priorR.D = ncZ * inv.VC, priorK.D = ncZ)\n    Data <- c(Data, x, y)\n    if (param %in% c(\"td-extra\", \"td-both\") && !is.null(extraForm))\n        Data <- c(Data, list(indFixed = extraForm$indFixed, \n            indRandom = extraForm$indRandom,\n            ncX.deriv = ncol(Xtime.deriv), ncZ.deriv = ncol(Ztime.deriv)))\n    if (survMod == \"weibull-PH\") {\n        Data <- c(Data, list(Time = Time, logTime = log(Time)))\n    } else {\n        Data <- c(Data, list(priorMean.Bs.gammas = Bs.gammas, \n            priorTau.Bs.gammas = diag(1 / var.Bs.gammas)))\n    }\n    if (param == \"shared-RE\") {\n        Data$priorMean.alphas <- rep(0, ncZ)\n        Data$priorTau.alphas <- diag(1 / rep(con$K, ncZ))\n    }\n    # user priors\n    if (!is.null(priors)) {\n        if (!is.list(priors) || !names(priors) %in% names(Data)) {\n            warning(\"'priors' is not a list with appropriate names (check the help file); \", \n                \"default priors are used instead.\\n\")\n        } else { \n            Data[names(priors)] <- priors\n        }\n    }\n    # initial values\n    initial.values <- list(betas = fixef(lmeObject), tau = 1/sigma2, \n        inv.D = inv.VC, gammas = gammas, b = b)\n    initial.values$alphas <- initial.values$Dalphas <- 0\n    if (param == \"shared-RE\")\n        initial.values$alphas <- rep(0, ncZ)\n    if (survMod == \"weibull-PH\") {\n        initial.values$sigma.t <- 1\n    } else {\n        initial.values$Bs.gammas <- rep(0.1, ncW2)\n    }\n    if (!is.null(init)) {\n        lngths <- lapply(initial.values[(nam.init <- names(init))], length)\n        if (!is.list(init) || !isTRUE(all.equal(lngths, lapply(init, length)))) {\n            warning(\"'init' is not a list with elements numeric vectors of appropriate \", \n                \"length; default starting values are used instead.\\n\")\n        } else {\n            initial.values[nam.init] <- init\n        }\n    }\n    # joint model fit\n    model <- switch(paste(survMod, param, robust, robust.b, sep = \"/\"),\n        \"weibull-PH/td-value/FALSE/FALSE\" = Weib.td.value,\n        \"weibull-PH/td-extra/FALSE/FALSE\" = Weib.td.slope,\n        \"weibull-PH/td-both/FALSE/FALSE\" = Weib.td.both,\n        \"weibull-PH/shared-RE/FALSE/FALSE\" = Weib.sharedRE,\n        \"spline-PH/td-value/FALSE/FALSE\" = spline.td.value,\n        \"spline-PH/td-extra/FALSE/FALSE\" = spline.td.slope,\n        \"spline-PH/td-both/FALSE/FALSE\" = spline.td.both,\n        \"spline-PH/shared-RE/FALSE/FALSE\" = spline.sharedRE,\n        ###            \n        \"weibull-PH/td-value/TRUE/FALSE\" = WeibRob.y.td.value,\n        \"weibull-PH/td-extra/TRUE/FALSE\" = WeibRob.y.td.slope,\n        \"weibull-PH/td-both/TRUE/FALSE\" = WeibRob.y.td.both,\n        \"weibull-PH/shared-RE/TRUE/FALSE\" = WeibRob.y.sharedRE,\n        \"spline-PH/td-value/TRUE/FALSE\" = splineRob.y.td.value,\n        \"spline-PH/td-extra/TRUE/FALSE\" = splineRob.y.td.slope,\n        \"spline-PH/td-both/TRUE/FALSE\" = splineRob.y.td.both,\n        \"spline-PH/shared-RE/TRUE/FALSE\" = splineRob.y.sharedRE,\n        ###\n        \"weibull-PH/td-value/FALSE/TRUE\" = WeibRob.b.td.value,\n        \"weibull-PH/td-extra/FALSE/TRUE\" = WeibRob.b.td.slope,\n        \"weibull-PH/td-both/FALSE/TRUE\" = WeibRob.b.td.both,\n        \"weibull-PH/shared-RE/FALSE/TRUE\" = WeibRob.b.sharedRE,\n        \"spline-PH/td-value/FALSE/TRUE\" = splineRob.b.td.value,\n        \"spline-PH/td-extra/FALSE/TRUE\" = splineRob.b.td.slope,\n        \"spline-PH/td-both/FALSE/TRUE\" = splineRob.b.td.both,\n        \"spline-PH/shared-RE/FALSE/TRUE\" = splineRob.b.sharedRE,\n        ###            \n        \"weibull-PH/td-value/TRUE/TRUE\" = WeibRob.yb.td.value,\n        \"weibull-PH/td-extra/TRUE/TRUE\" = WeibRob.yb.td.slope,\n        \"weibull-PH/td-both/TRUE/TRUE\" = WeibRob.yb.td.both,\n        \"weibull-PH/shared-RE/TRUE/TRUE\" = WeibRob.yb.sharedRE,\n        \"spline-PH/td-value/TRUE/TRUE\" = splineRob.yb.td.value,\n        \"spline-PH/td-extra/TRUE/TRUE\" = splineRob.yb.td.slope,\n        \"spline-PH/td-both/TRUE/TRUE\" = splineRob.yb.td.both,\n        \"spline-PH/shared-RE/TRUE/TRUE\" = splineRob.yb.sharedRE)\n    namesModel <- namesJMbayes(survMod, param, robust, robust.b)\n    parms <- c(\"betas\", \"tau\", \"inv.D\", \"gammas\", \"b\")\n    parms <- switch(paste(survMod, param, sep = \"/\"),\n        \"weibull-PH/td-value\" = c(parms, \"alphas\", \"sigma.t\"),\n        \"weibull-PH/td-extra\" = c(parms, \"Dalphas\", \"sigma.t\"),\n        \"weibull-PH/td-both\" = c(parms, \"alphas\", \"Dalphas\", \"sigma.t\"),\n        \"weibull-PH/shared-RE\" = c(parms, \"alphas\", \"sigma.t\"),\n        \"spline-PH/td-value\" = c(parms, \"alphas\", \"Bs.gammas\"),\n        \"spline-PH/td-extra\" = c(parms, \"Dalphas\", \"Bs.gammas\"),\n        \"spline-PH/td-both\" = c(parms, \"alphas\", \"Dalphas\", \"Bs.gammas\"),\n        \"spline-PH/shared-RE\" = c(parms, \"alphas\", \"Bs.gammas\"))\n    write.model.JMbayes(model, file.path(con$working.directory, \"JM.txt\"), Data, \n        param, extraForm, con$program)\n    Data <- Data[names(Data) %in% namesModel]\n    initial.values <- initial.values[names(initial.values) %in% parms]\n    fit <- if (con$program %in% c(\"WinBUGS\", \"winbugs\")) {\n        if (!require(\"R2WinBUGS\")) \n            stop(\"'R2WinBUGS' is required.\\n\")\n        R2WinBUGS::bugs(Data, list(initial.values), parms, model.file = \"JM.txt\", \n            n.chains = con$n.chains, n.iter = con$n.iter, n.burnin = con$n.burnin, \n            n.thin = con$n.thin, working.directory = con$working.directory, \n            clearWD = con$clearWD, bugs.directory = con$bugs.directory, \n            over.relax = con$over.relax, bugs.seed = con$bugs.seed)\n    } else if (con$program %in% c(\"OpenBUGS\", \"openbugs\")) {\n        if (!require(\"R2OpenBUGS\")) \n            stop(\"'R2OpenBUGS' is required.\\n\")\n        R2OpenBUGS::bugs(Data, list(initial.values), parms, model.file = \"JM.txt\", \n            n.chains = con$n.chains, n.iter = con$n.iter, n.burnin = con$n.burnin, \n            n.thin = con$n.thin, clearWD = con$clearWD, over.relax = con$over.relax, \n            bugs.seed = con$bugs.seed, working.directory = con$working.directory,\n            OpenBUGS.pgm = con$openbugs.directory)\n    } else if (con$program %in% c(\"JAGS\", \"jags\")) {\n        if (!require(\"rjags\")) \n            stop(\"'rjags' is required.\\n\")\n        JMjags.model <- jags.model(file = \"JM.txt\", data = Data, inits = list(initial.values),\n            n.chains = con$n.chains, n.adapt = con$n.adapt, quiet = con$quiet)\n        update(JMjags.model, con$n.burnin)\n        coda.samples(JMjags.model, parms, n.iter = con$n.iter - con$n.burnin, thin = con$n.thin)\n    } else {\n        stop(\"'program' should be one of 'WinBUGS', 'winbugs', 'OpenBUGS', 'openbugs', \",\n            \"'JAGS', 'jags'.\\n\")\n    }\n    file.remove(file.path(con$working.directory, \"JM.txt\"))\n    # output result\n    codaFit <- as.mcmc.list(fit)\n    Bs <- do.call(rbind, codaFit)\n    ind.bs <- grep(\"b[\", colnames(Bs), fixed = TRUE)\n    ranef <- Bs[, ind.bs, drop = FALSE]\n    ord.col <- sapply(strsplit(colnames(ranef), \"[\", fixed = TRUE), \"[\", 2)\n    ord.col <- sapply(strsplit(ord.col, \",\", fixed = TRUE), \"[\", 1)\n    ord.col <- order(as.numeric(ord.col))\n    ranef <- ranef[, ord.col, drop = FALSE]\n    postMeans <- matrix(colMeans(ranef), ncol = ncol(Z), byrow = TRUE)\n    dimnames(postMeans) <- list(levels(factor(lmeObject$groups[[1]])), colnames(Z))\n    postVars <- vector(\"list\", nrow(postMeans))\n    ind.var <- matrix(seq_len(ncol(ranef)), ncol = ncol(Z), byrow = TRUE)\n    for (i in seq_along(postVars))\n        postVars[[i]] <- var(ranef[, ind.var[i, ]])\n    postVars[] <- lapply(postVars, function (m) { \n        dimnames(m) <- list(colnames(postMeans), colnames(postMeans))\n        m\n    })\n    names(postVars) <- rownames(postMeans)\n    if (one.RE) {\n        postMeans <- postMeans[, 1, drop = FALSE]\n        postVars <- lapply(postVars, function (m) m[1, 1, drop = FALSE])\n    }\n    #\n    n.sims <- nrow(Bs)\n    sims.list <- vector(\"list\", length(parms))\n    names(sims.list) <- parms\n    for (p in seq_along(parms)) {\n        ii <- grep(paste(\"^\", parms[p], sep = \"\"), colnames(Bs))\n        sims.list[[p]] <- Bs[, ii]\n    }\n    sims.list$b <- NULL\n    h <- function (b, thetas) {\n        thetas <- relist(thetas, skeleton = list.thetas)\n        betas <- thetas$betas\n        sigma <- thetas$sigma\n        gammas <- thetas$gammas\n        alphas <- thetas$alphas\n        Dalphas <- thetas$Dalphas\n        sigma.t <- thetas$sigma.t\n        D <- thetas$D\n        n <- length(y$logT)\n        mu.y <- c(x$X %*% betas) + rowSums(x$Z * b[id, , drop = FALSE])\n        log.p.y.b <- if (!robust) dnorm(y$y, mu.y, sigma, log = TRUE) \n            else dgt(y$y, mu.y, sigma, df, log = TRUE)\n        log.p.y.b <- tapply(log.p.y.b, id, sum)\n        log.p.b <- if (!robust.b) dmvnorm(b, rep(0, ncol(b)), D, log = TRUE)\n            else dmvt(b, rep(0, ncol(b)), D, df.b, log = TRUE)\n        eta.t <- if (!is.null(gammas)) c(x$W %*% rep(gammas, length.out = ncol(x$W))) \n            else rep(0, n)\n        id.GK <- rep(seq_along(y$logT), each = 15)\n        wk.long <- rep(wk, n)\n        if (param %in% c(\"td-value\", \"td-both\")) {\n            Y <- c(x$Xtime %*% betas) + rowSums(x$Ztime * b)\n            Ys <- c(x$Xs %*% betas) + rowSums(x$Zs * b[id.GK, , drop = FALSE])\n        }\n        if (param %in% c(\"td-extra\", \"td-both\")) {\n            Yderiv <- c(x$Xtime.deriv %*% betas[extraForm$indFixed]) + \n                rowSums(x$Ztime.deriv * b[, extraForm$indRandom, drop = FALSE])\n            Ys.deriv <- c(x$Xs.deriv %*% betas[extraForm$indFixed]) + \n                rowSums(x$Zs.deriv * b[id.GK, extraForm$indRandom, drop = FALSE])\n        }\n        longSurv <- switch(param,\n            \"td-value\" = alphas * Y, \n            \"td-extra\" = Dalphas * Yderiv,\n            \"td-both\" = alphas * Y + Dalphas * Yderiv,\n            \"shared-RE\" = c(b %*% alphas))\n        longSurv.s <- switch(param,\n            \"td-value\" = alphas * Ys, \n            \"td-extra\" = Dalphas * Ys.deriv,\n            \"td-both\" = alphas * Ys + Dalphas * Ys.deriv,\n            \"shared-RE\" = c(b %*% alphas)[id.GK])\n        if (survMod == \"weibull-PH\") {\n            log.hazard <- log(sigma.t) + (sigma.t - 1) * y$logT + eta.t + longSurv\n            log.survival <- - exp(eta.t) * P * tapply(wk.long * exp(log(sigma.t) + \n                (sigma.t - 1) * log(c(t(st))) + longSurv.s), id.GK, sum)\n        } else {\n            log.hazard <- c(x$W2 %*% Bs.gammas) + eta.t + longSurv\n            log.survival <- - exp(eta.t) * P * tapply(wk.long * exp(c(W2s %*% Bs.gammas) + \n                longSurv.s), id.GK, sum)\n        }\n        log.p.t.b <- event * log.hazard + log.survival\n        - 2 * sum(log.p.y.b + log.p.t.b + log.p.b, na.rm = TRUE)\n    }\n    out <- list(codaFit = lapply(codaFit, function (x) x[, -ind.bs, drop = FALSE]),\n        postMeans = postMeans, postVars = postVars)\n    class(out$codaFit) <- \"mcmc.list\"\n    ncz <- ncol(Z)\n    indD <- cbind(rep(1:ncz, each = ncz), rep(1:ncz, ncz))\n    DD <- t(sapply(seq_len(n.sims), function (i) {\n        m <- matrix(0, ncz, ncz)\n        m[indD] <- sims.list$inv.D[i, ]\n        d <- solve(m)\n        d[lower.tri(d, TRUE)]\n    }))\n    sims.list <- list(betas = sims.list$betas, sigma = sqrt(1 / sims.list$tau),\n        gammas = sims.list$gammas, alphas = sims.list$alphas, \n        Dalphas = sims.list$Dalphas, sigma.t = sims.list$sigma.t,\n        Bs.gammas = sims.list$Bs.gammas, D = DD)\n    if (is.null(W)) {\n        sims.list$gammas <- if (survMod == \"weibull-PH\") sims.list$gammas[, 1, drop = FALSE] else NULL\n    }\n    if (survMod == \"spline-PH\" && !is.null(W) && ncol(W) == 1)\n        sims.list$gammas <- sims.list$gammas[, 1, drop = FALSE]\n    colnames(sims.list$betas) <- colnames(X)\n    colnames(sims.list$gammas) <- if (survMod == \"weibull-PH\") {\n        if (is.null(W)) \"(Intercept)\" else c(\"(Intercept)\", colnames(W)) \n    } else colnames(W)\n    if (survMod == \"spline-PH\")\n        colnames(sims.list$Bs.gammas) <- paste(\"gamma.bs\", seq_len(ncW2), sep = \"\")\n    colnames(sims.list$D) <- paste(\"D[\", row(VC)[lower.tri(VC, TRUE)], \", \", \n        col(VC)[lower.tri(VC, TRUE)], \"]\", sep = \"\") \n    sims.list <- sims.list[!sapply(sims.list, is.null)]\n    out$modes <- lapply(sims.list, function (x) {\n        m <- function (x) {\n            d <- density(x, bw = \"nrd\", adjust = 3, n = 1000)\n            d$x[which.max(d$y)]\n        }\n        if (is.matrix(x)) apply(x, 2, m) else m(x)\n    })\n    out$coefficients <- lapply(sims.list, \n        function (x) if (is.matrix(x)) colMeans(x) else mean(x))\n    out$StErr <- lapply(sims.list, \n        function (x) {\n            f <- function (x) {\n                acf.x <- drop(acf(x, lag.max = 0.4*length(x), plot = FALSE)$acf)[-1]\n                acf.x <- acf.x[seq_len(rle(acf.x > 0)$lengths[1])]\n                ess <- length(x) / (1 + 2 * sum(acf.x))\n                sqrt(var(x) / ess)\n            }\n            if (is.matrix(x)) apply(x, 2, f) else f(x)\n    })\n    out$StDev <- lapply(sims.list, function (x) \n        if (is.matrix(x)) apply(x, 2, sd) else sd(x))\n    out$CIs <- lapply(sims.list, \n        function (x) if (is.matrix(x)) apply(x, 2, quantile, probs = c(0.025, 0.975)) \n            else quantile(x, probs = c(0.025, 0.975)))\n    out$vcov <- var(do.call(cbind, sims.list)) \n    D <- matrix(0, nrow(VC), ncol(VC))\n    D[lower.tri(D, TRUE)] <- out$coefficients$D\n    D <- D + t(D)\n    diag(D) <- diag(D) / 2\n    out$coefficients$D <- D\n    dimnames(out$coefficients$D) <- dimnames(VC)\n    D <- matrix(0, nrow(VC), ncol(VC))\n    D[lower.tri(D, TRUE)] <- out$modes$D\n    D <- D + t(D)\n    diag(D) <- diag(D) / 2\n    out$modes$D <- D\n    dimnames(out$modes$D) <- dimnames(VC)    \n    if (one.RE) {\n        out$coefficients$D <- out$coefficients$D[1, 1, drop = FALSE]\n        dimnames(out$coefficients$D) <- list(colnames(Z)[1], colnames(Z)[1])\n        if (param == \"shared-RE\") {\n            out$coefficients$alphas <- out$coefficients$alphas[1]\n            names(out$coefficients$alphas) <- colnames(Z)[1]\n        }\n        x$Z <- x$Z[, 1, drop = FALSE]\n        if (!is.null(x$Ztime))\n            x$Ztime <- x$Ztime[, 1, drop = FALSE]\n    }\n    list.thetas <- out$coefficients\n    thetas <- unlist(as.relistable(list.thetas))\n    D.hat <- h(postMeans, thetas)\n    M <- nrow(sims.list$betas)\n    hat.Ds <- numeric(M)\n    for (m in seq_len(M)) {\n        postMeans.m <- matrix(ranef[m, ], ncol = ncol(Z), byrow = TRUE)\n        thetas.m <- lapply(sims.list, function (x)\n            if (is.matrix(x)) x[m, ] else x[m])\n        D <- matrix(0, nrow(VC), ncol(VC))\n        D[lower.tri(D, TRUE)] <- thetas.m$D\n        D <- D + t(D)\n        diag(D) <- diag(D) / 2\n        thetas.m$D <- D\n        thetas.m <- unlist(as.relistable(thetas.m))\n        hat.Ds[m] <- h(postMeans.m, thetas.m)\n    }\n    hat.D <- mean(hat.Ds, na.rm = TRUE)\n    out$pD <- hat.D - D.hat \n    out$DIC <- out$pD + hat.D\n    rm(ranef, Bs, codaFit, sims.list)\n    out$x <- x\n    out$y <- y\n    out$id <- id\n    names(out$id) <- factor(lmeObject$groups[[1]])\n    out$times <- data[[timeVar]]\n    out$data <- data\n    out$data.id <- data.id\n    out$survMod <- survMod\n    out$termsYx <- TermsX\n    out$termsYz <- TermsZ\n    if (param %in% c(\"td-extra\", \"td-both\")) {\n        out$termsYx.deriv <- TermsX.deriv\n        out$termsYz.deriv <- TermsZ.deriv\n    }\n    out$termsT <- survObject$terms\n    out$formYx <- formYx\n    out$formYz <- formYz\n    out$formT <- formT\n    out$timeVar <- timeVar\n    out$control <- con\n    out$param <- param\n    out$extraForm <- extraForm\n    out$robust <- robust\n    out$robust.b <- robust.b\n    out$df <- df\n    out$df.b <- df.b\n    out$priors <- Data[grep(\"prior\", names(Data), fixed = TRUE)]\n    out$call <- cl\n    class(out) <- \"JMbayes\"\n    out\n}\n",
    "created" : 1447616335669.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "526050755",
    "id" : "F06234CE",
    "lastKnownWriteTime" : 1369055614,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/TestFiles/JMbayes/JMBayes_Old.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_source"
}