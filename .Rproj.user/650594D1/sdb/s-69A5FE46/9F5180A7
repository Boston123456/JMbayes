{
    "contents" : "library(MASS)\nlibrary(nlme)\nlibrary(splines)\nlibrary(survival)\nlibrary(lattice)\n\nroot <- \"C:/Users/Dimitris/Docume~1/PackagesSource/JMbayes/\"\nsource(paste(root, \"vers2/Rpgm/make package.R\", sep = \"\"))\n\n#############################################\n\npbc2$status2 <- as.numeric(pbc2$status != \"alive\")\npbc2.id$status2 <- as.numeric(pbc2.id$status != \"alive\")\npbc2$serBilirD <- 1 * (pbc2$serBilir > 1.8)\nind <- as.logical(with(pbc2, ave(serChol, id, FUN = function (x) !all(is.na(x)))))\npbc2 <- pbc2[ind, ]\npbc2.id <- pbc2[!duplicated(pbc2$id), ]\nlmeFit1 <- lme(log(serBilir) ~ ns(year, 2),\n              random = ~ ns(year, 2) | id, data = pbc2)\nlmeFit2 <- glmmPQL(serBilirD ~ year, random = ~ year | id, family = binomial, data = pbc2)\nlmeFit3 <- lme(serChol ~ ns(year, 2), random = ~ ns(year, 2) | id, data = pbc2,\n               na.action = na.exclude)\nsurvFit <- survFit <- coxph(Surv(years, status2) ~ drug * age, data = pbc2.id, x = TRUE)\n\n\nlmeObject <- list(lmeFit1, lmeFit2)\nlmeObject <- list(lmeFit1, lmeFit3)\nsurvObject <- survFit\ndensLong <- NULL\ntimeVar <- \"year\"\ntransFun <- NULL\nlag <- 0\nparam <- \"td-value\"\n\ndensLong <- function (y, eta.y, scale, log = FALSE, data, outcome, \n                      isMultivariate) {\n    out1 <- outcome == 1L\n    out2 <- outcome == 2L\n    pdf1 <- dnorm(x = y[out1], mean = eta.y[out2], sd = scale[1L], log = log)\n    pdf2 <- dbinom(x = y[out2], size = 1L, prob = plogis(eta.y[out2]), log = log)\n    c(pdf1, pdf2)\n}\n\n\n#########################################################################################\n\nextract <- function (lis, name, ord, unlist = FALSE, cbind = FALSE, bdiag = FALSE) {\n    out <- lapply(lis, \"[[\", name)\n    if (bdiag) {\n        out <- if (!missing(ord)) bdiag(out)[ord, , drop = FALSE] else bdiag(out)\n    }\n    if (unlist && missing(ord))\n        out <- unlist(out, use.names = FALSE)\n    if (unlist && !missing(ord))\n        out <- unlist(out, use.names = FALSE)[ord]\n    if (cbind)\n        out <- if (any(sapply(out, is.matrix))) \n            do.call(\"cbind\", out) else do.call(\"c\", out)\n    out\n}\n\nframesLME <- function (object, timeVar = \"year\") {\n    b <- data.matrix(ranef(object))\n    dimnames(b) <- NULL\n    nY <- nrow(b)\n    formYx <- formula(object)\n    formYz <- formula(object$modelStruct$reStruct[[1]])\n    vars <- unique(c(all.vars(formYx), all.vars(formYz)))\n    data <- object$data\n    na.ind <- complete.cases(data[vars])\n    data <- data[na.ind, , drop = FALSE]\n    idVar <- names(object$groups)\n    idOrig <- object$groups[[1L]]\n    id <- as.vector(unclass(idOrig))\n    times <- data[[timeVar]]\n    mfX <- model.frame(terms(formYx), data = data)\n    TermsX <- attr(mfX, \"terms\")\n    X <- model.matrix(formYx, mfX)\n    mfZ <- model.frame(terms(formYz), data = data)\n    TermsZ <- attr(mfZ, \"terms\")\n    Z <- model.matrix(formYz, mfZ)\n    y.long <- model.response(mfX, \"numeric\")\n    betas <- fixef(object)\n    long <- c(X %*% betas) + rowSums(Z * b[id, ])\n    sigma <- object$sigma\n    sigma2 <- sigma^2\n    D <- lapply(pdMatrix(object$modelStruct$reStruct), \"*\", sigma^2)[[1]]\n    invD <- solve(D)\n    Cov.postRE <- vector(\"list\", nY)\n    for (i in seq_len(nY)) {\n        Z.i <- Z[id == i, , drop = FALSE]\n        Cov.postRE[[i]] <- solve(crossprod(Z.i) / sigma2 + invD)        \n    }\n    list(idOrig = idOrig, id = id, idVar = idVar, b = b, nY = nY, n = length(y.long), \n         data = data, times = times, formYx = formYx, TermsX = TermsX, X = X, \n         formYz = formYz, TermsZ = TermsZ, Z = Z,\n         y.long = y.long, long = long, betas = betas, D = D, invD = invD, \n         sigma = sigma, Cov.postRE = Cov.postRE, isGLMM = inherits(object, \"glmmPQL\"))\n}\n\nX_matrix <- function (components, data, formula = NULL) {\n    TermsX <- delete.response(components$TermsX)\n    mfX <- model.frame(TermsX, data = data)\n    if (is.null(formula))\n        formula <- reformulate(attr(TermsX, \"term.labels\"))\n    model.matrix(formula, mfX)\n}\n\nZ_matrix <- function (components, data, formula = NULL) {\n    mfZ <- model.frame(components$TermsZ, data = data)\n    if (is.null(formula))\n        formula <- components$formYz\n    model.matrix(formula, mfZ)\n}\n\ndata_td <- function (data, timeVar, idVar, times_s) {\n    times <- data[[timeVar]]\n    id <- data[[idVar]]\n    id <- match(id, unique(id))\n    ind <- mapply(findInterval, x = split(times_s, row(times_s)), vec = split(times, id), \n                  SIMPLIFY = FALSE)\n    do.call(rbind, mapply(function (x, i) x[i, , drop = FALSE], x = split(data, id),\n                          i = ind, SIMPLIFY = FALSE))\n}\n\nxx1 <- data_td(data[[1]], \"year\", \"id\", st)\nxx2 <- data_td(data[[2]], \"year\", \"id\", st)\n\neta_long <- function (X, betas, Z, b, nrow, ncol, id = NULL) {\n    drop(X %*% betas) + \n        if (is.null(id)) .rowSums(Z * b, nrow, ncol) \n    else .rowSums(Z * b[id, , drop = FALSE], nrow, ncol)\n}\n\n##########################################################################################\n\nif (inherits(lmeObject, \"lme\"))\n    lmeObject <- list(lmeObject)\nif (!all(sapply(lmeObject, inherits, \"lme\")))\n    stop(\"\\n'lmeObject' must inherit from class lme.\")\nif (any(sapply(lmeObject, function (m) length(m$group) > 1)))\n    stop(\"\\nnested random-effects are not allowed in lme().\")\nif (!all(sapply(lmeObject, function (m) is.null(m$modelStruct$corStruct))))\n    warning(\"correlation structure in 'lmeObject' is ignored.\\n\")\n# extract response & design matrix survival process\nformT <- formula(survObject)\nW <- survObject$x\nif (!length(W))\n    W <- NULL\nSurvInf <- survObject$y\ntypeSurvInf <- attr(SurvInf, \"type\")\nif (typeSurvInf == \"right\") {\n    Time <- SurvInf[, \"time\"]\n    Time[Time < 1e-04] <- 1e-04\n    nT <- length(Time)\n    event <- SurvInf[, \"status\"]\n    LongFormat <- FALSE\n}\nif (typeSurvInf == \"counting\") {\n    if (is.null(survObject$model))\n        stop(\"\\nplease refit the Cox model including in the \", \n             \"call to coxph() the argument 'model = TRUE'.\")\n    idT <- if (!is.null(survObject$model$cluster)) {\n        as.vector(unclass(survObject$model$cluster))\n    } else {\n        seq_len(nrow(survObject$model))\n    }\n    idT <- match(idT, unique(idT))\n    LongFormat <- length(idT) > length(unique(idT))\n    TimeL <- TimeLl <- SurvInf[, \"start\"]\n    TimeL <- tapply(TimeL, idT, head, n = 1)\n    anyLeftCens <- any(TimeL > 1e-07)\n    TimeR <- SurvInf[, \"stop\"]\n    TimeR[TimeR < 1e-04] <- 1e-04\n    Time <- tapply(TimeR, idT, tail, n = 1)\n    nT <- length(Time)\n    eventLong <- SurvInf[, \"status\"]\n    event  <- tapply(eventLong, idT, tail, n = 1)\n}\nisMultivariate <- length(lmeObject) > 1L\nlmeComponents <- lapply(lmeObject, framesLME)\nnY <- extract(lmeComponents, \"nY\", unlist = TRUE)\nif (!all(nY == nY[1L]))\n    stop(\"lme objects imply different number of subjects.\\n\")\nnY <- nY[1L]\nreord <- order(extract(lmeComponents, \"id\", unlist = TRUE))\noutcome <- rep(seq_along(lmeObject), extract(lmeComponents, \"n\", unlist = TRUE))[reord]\nid <- extract(lmeComponents, \"id\", reord, unlist = TRUE)\nidOrig <- extract(lmeComponents, \"idOrig\", reord, unlist = TRUE)\ntimes <- extract(lmeComponents, \"times\", reord, unlist = TRUE)\nmax.timeY <- tapply(times, id, max)\n#if (!all(Time >= max.timeY)) {\n#    idnams <- factor(idOrig)\n#    stop(\"\\nit seems that there are longitudinal measurements taken after the event times for some subjects \",\n#         \"(i.e., check subject(s): \", paste(levels(idnams)[(Time < max.timeY)], collapse = \", \"), \").\")\n#}\ny.long <- extract(lmeComponents, \"y.long\", reord, unlist = TRUE)\nX <- extract(lmeComponents, \"X\", reord, bdiag = TRUE)\nZ <- extract(lmeComponents, \"Z\", reord, bdiag = TRUE)\nb <- extract(lmeComponents, \"b\", cbind = TRUE)\nb_list <- extract(lmeComponents, \"b\")\nisGLMM <- extract(lmeComponents, \"isGLMM\", cbind = TRUE)\nbetas <- extract(lmeComponents, \"betas\", cbind = TRUE)\nbetas_list <- extract(lmeComponents, \"betas\")\nsigma <- extract(lmeComponents, \"sigma\", cbind = TRUE)\nD <- extract(lmeComponents, \"D\", bdiag = TRUE)\nlong <- extract(lmeComponents, \"long\", reord, unlist = TRUE)\nif (densLongCheck <- is.null(densLong)) {\n    if (all(sapply(lmeObject, function (m) is.null(m$family)))) {\n        densLong <- function (y, eta.y, scale, log = FALSE, data, outcome, \n                              isMultivariate) {\n            if (isMultivariate) \n                dnorm(x = y, mean = eta.y, sd = scale[outcome], log = log)\n            else\n                dnorm(x = y, mean = eta.y, sd = scale, log = log)\n        }\n    } else {\n        stop(\"you should define 'densLong' appropriately.\\n\")\n    }\n} else {\n    if (!is.function(densLong) || \n            !names(formals(densLong)) %in% c(\"y\", \"eta.y\", \"scale\", \"log\", \"data\", \n                                             \"outcome\", \"isMultivariate\"))\n        stop(\"invalid specification of densLong(); check the help file.\")\n}\nidVar <- extract(lmeComponents, \"idVar\", unlist = TRUE)\nif (!all(idVar == idVar[1L]))\n    warning(\"it seems the mixed models have been fitted in data sets with \",\n            \"different subject id variables.\")\nidVar <- idVar[1L]\ndata <- extract(lmeComponents, \"data\")\ndata <- do.call(merge, c(data, list (sort = FALSE, all = TRUE)))\ndata <- data[order(data[[idVar]], data[[timeVar]]), , drop = FALSE]\nCov.postRE <- extract(lmeComponents, \"Cov.postRE\")\nCov.postRE <- lapply(seq_len(nY), \n                     function (i, l) bdiag(lapply(l, \"[[\", i = i)), l = Cov.postRE)\nif (is.null(transFun)) {\n    outcome_interaction <- outer(outcome, unique(outcome), \"==\")\n    transFun.value <- transFun.extra <- function (x, data, isMultivariate, \n                                                  outcome_interaction, outcome) {\n        if (isMultivariate) x * outcome_interaction else x\n    }\n} else {\n    if (is.function(transFun)) {\n        transFun.value <- transFun.extra <- transFun\n    }\n    if (is.list(transFun)) {\n        transFun.value <- transFun$value\n        transFun.extra <- transFun$extra\n    }\n    nms_tfuns <- c(\"x\", \"data\", \"isMultivariate\", \"outcome_interaction\", \"outcome\")\n    if (any(!names(formals(transFun.value)) %in% nms_tfuns))\n        stop(\"\\nincorrect specification of 'transFun' arguments; see help file.\")\n    if (any(!names(formals(transFun.extra)) %in% nms_tfuns))\n        stop(\"\\nincorrect specification of 'transFun' arguments; see help file.\")\n}\nhasScale <- as.logical(length(grep(\"scale\", as.character(body(densLong)), fixed = TRUE)))\n# construct desing matrices for longitudinal part for the hazard function\ndata.id <- data[!duplicated(data[[idVar]]), , drop = FALSE]\ndata.id[[timeVar]] <- pmax(Time - lag, 0)\nif (param %in% c(\"td-value\", \"td-both\")) {\n    Xtime <- lapply(lmeComponents, X_matrix, data = data.id)\n    Ztime <- lapply(lmeComponents, Z_matrix, data = data.id)\n}\n\nncz_list <- lapply(Ztime, ncol)\nmapply(eta_long, X = Xtime, betas = betas_list, Z = Ztime, b = b_list, \n       ncol = ncz_list, MoreArgs = list(nrow = nY))\n\n\n\n\nall.equal(long, c(X %*% betas) + rowSums(Z * b[id, ]))\n\nlapply(split(densLong(y.long, eta.y = long, scale = sigma, outcome = outcome, \n                      log = TRUE, isMultivariate = isMultivariate), outcome), sum)\n\n\n\n\n####################################################################\n\nl <- list(list(1:3, 4:6), list(1:3, 4:6))\nunlist(l, recursive = FALSE)\n\n\n##########################################################################################\n##########################################################################################\n##########################################################################################\n##########################################################################################\n\n\n# Survival\n\nsurvObject <- coxph(Surv(start, stop, event) ~ drug + gender + CD4 + cluster(patient), data = aids, x = TRUE, model = TRUE)\nsurvObject <- coxph(Surv(start, Time, event) ~ drug + gender, data = aids.id, x = TRUE, model = TRUE)\n\nsurvObject <- coxph(Surv(Time, death) ~ drug + gender, data = aids.id, x = TRUE)\n\nformT <- formula(survObject)\nW <- survObject$x\nif (!length(W))\n    W <- NULL\nSurvInf <- survObject$y\ntypeSurvInf <- attr(SurvInf, \"type\")\nif (typeSurvInf == \"right\") {\n    Time <- SurvInf[, \"time\"]\n    Time[Time < 1e-04] <- 1e-04\n    nT <- length(Time)\n    event <- SurvInf[, \"status\"]\n}\nif (typeSurvInf == \"counting\") {\n    if (is.null(survObject$model))\n        stop(\"\\nplease refit the Cox model including in the \", \n             \"call to coxph() the argument 'model = TRUE'.\")\n    idT <- if (!is.null(survObject$model$cluster)) {\n        as.vector(unclass(survObject$model$cluster))\n    } else {\n        seq_len(nrow(survObject$model))\n    }\n    idT <- match(idT, unique(idT))\n    LongFormat <- length(idT) > length(unique(idT))\n    TimeL <- SurvInf[, \"start\"]\n    TimeL <- tapply(TimeL, idT, head, n = 1)\n    TimeR <- SurvInf[, \"stop\"]\n    TimeR[TimeR < 1e-04] <- 1e-04\n    Time <- tapply(TimeR, idT, tail, n = 1)\n    nT <- length(Time)\n    eventLong <- SurvInf[, \"status\"]\n    event  <- tapply(eventLong, idT, tail, n = 1)\n}\n\n\nTDind <- mapply(findInterval, x = split(st, row(st)), vec = split(TimeL, idT), \n                SIMPLIFY = FALSE)\n\nWs <- do.call(rbind, mapply(function (x, i) x[i, , drop = FALSE], \n                            x = lapply(split(W, idT), matrix, ncol = ncol(W)), i = TDind, \n                            SIMPLIFY = FALSE))\ncolnames(Ws) <- colnames(W)\n\n\n\n\n\n\n\n\n\n",
    "created" : 1447616271140.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1810465564",
    "id" : "9F5180A7",
    "lastKnownWriteTime" : 1409338777,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/TestFiles/JMbayes/Formulas.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "type" : "r_source"
}