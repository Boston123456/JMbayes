{
    "contents" : "marglogLik <-\nfunction (object, newdata, idVar = \"id\", method = \"BFGS\", control = NULL) {\n    if (!inherits(object, \"JMbayes\"))\n        stop(\"Use only with 'JMbayes' objects.\\n\")\n    if (!is.data.frame(newdata) || nrow(newdata) == 0)\n        stop(\"'newdata' must be a data.frame with more than one rows.\\n\")\n    if (is.null(newdata[[idVar]]))\n        stop(\"'idVar' not in 'newdata.\\n'\")\n    timeVar <- object$timeVar\n    baseHaz <- object$baseHaz\n    df.RE <- object$df.RE\n    param <- object$param\n    extraForm <- object$Forms$extraForm\n    indFixed <- extraForm$indFixed\n    indRandom <- extraForm$indRandom\n    estimateWeightFun <- object$estimateWeightFun\n    weightFun <- object$Funs$weightFun\n    max.time <- max(object$y$Time)\n    TermsX <- object$Terms$termsYx\n    TermsZ <- object$Terms$termsYz\n    TermsX.extra <- object$Terms$termsYx.extra\n    TermsZ.extra <- object$Terms$termsYz.extra\n    mfX <- model.frame(TermsX, data = newdata)\n    mfZ <- model.frame(TermsZ, data = newdata)\n    formYx <- reformulate(attr(delete.response(TermsX), \"term.labels\"))\n    formYz <- object$Forms$formYz\n    na.ind <- as.vector(attr(mfX, \"na.action\"))\n    na.ind <- if (is.null(na.ind)) {\n        rep(TRUE, nrow(newdata))\n    } else {\n        !seq_len(nrow(newdata)) %in% na.ind\n    }\n    indBetas <- object$y$indBetas\n    id <- as.numeric(unclass(newdata[[idVar]]))\n    id <- id. <- match(id, unique(id))\n    id <- id[na.ind]\n    y <- model.response(mfX)\n    X <- model.matrix(formYx, mfX)\n    Z <- model.matrix(formYz, mfZ)[na.ind, , drop = FALSE]\n    TermsT <- object$Terms$termsT\n    data.id <- newdata[!duplicated(id), ]\n    data.s <- data.id[rep(1:nrow(data.id), each = 15), ]\n    idT <- data.id[[idVar]]\n    idT <- match(idT, unique(idT))\n    ids <- data.s[[idVar]]\n    ids <- match(ids, unique(ids))\n    mfT <- model.frame(delete.response(TermsT), data = data.id)\n    formT <- if (!is.null(kk <- attr(TermsT, \"specials\")$strata)) {\n        strt <- eval(attr(TermsT, \"variables\"), data.id)[[kk]]\n        tt <- drop.terms(TermsT, kk - 1, keep.response = FALSE)\n        reformulate(attr(tt, \"term.labels\"))\n    } else if (!is.null(kk <- attr(TermsT, \"specials\")$cluster)) {\n        tt <- drop.terms(TermsT, kk - 1, keep.response = FALSE)\n        reformulate(attr(tt, \"term.labels\"))\n    } else {\n        tt <- attr(delete.response(TermsT), \"term.labels\")\n        if (length(tt)) reformulate(tt) else reformulate(\"1\")\n    }\n    W <- model.matrix(formT, mfT)[, -1, drop = FALSE]\n    last.time <- tapply(newdata[[timeVar]], id., tail, n = 1)\n    n.tp <- length(last.time)\n    ncx <- ncol(X)\n    ncz <- ncol(Z)\n    ncww <- ncol(W)\n    lag <- object$y$lag\n    densLong <- object$Funs$densLong\n    densRE <- object$Funs$densRE\n    transFun.value <- object$Funs$transFun.value\n    transFun.extra <- object$Funs$transFun.extra\n    # list of parameters\n    list.thetas <- c(object$postModes, list(ranef = rep(0, ncz) ))\n    if (!is.null(list.thetas$sigma))\n        list.thetas$sigma <- log(list.thetas$sigma)\n    if (!is.null(list.thetas$tauBs))\n        list.thetas$tauBs <- log(list.thetas$tauBs)\n    list.thetas$D <- chol.transf(list.thetas$D)\n    thetas.b <- unlist(as.relistable(list.thetas))\n    # construct model matrices to calculate the log.posterior\n    environment(ModelMats) <- environment()\n    survMats.last <- vector(\"list\", n.tp)\n    for (i in seq_along(last.time)) {\n        survMats.last[[i]] <- ModelMats(last.time[i], ii = i)\n    }\n    logPost <- function (thetas.b, ii, transform = TRUE) {\n        # parameters\n        tht <- relist(thetas.b, list.thetas)\n        betas <- tht$betas        \n        gammas <- tht$gammas\n        alphas <- tht$alphas\n        Dalphas <- tht$Dalphas\n        Bs.gammas <- tht$Bs.gammas\n        sigma <- tht$sigma\n        tauBs <- tht$tauBs\n        b <- tht$ranef\n        if (transform) {\n            if (!is.null(sigma)) sigma <- exp(tht$sigma)\n            if (!is.null(tauBs)) tauBs <- exp(tauBs)\n            D <- chol.transf(tht$D)\n        } else {\n            sigma <- tht$sigma\n            D <- matrix(0, ncz, ncz)\n            D[lower.tri(D, TRUE)] <- tht$D\n            D <- D + t(D)\n            diag(D) <- diag(D) / 2\n        }\n        # log-likelihood contributions\n        id.i <- id %in% ii\n        idT.i <- idT %in% ii\n        ids.i <- ids %in% ii\n        X.i <- X[id.i, , drop = FALSE]\n        Z.i <- Z[id.i, , drop = FALSE]\n        mu.y <- as.vector(X.i %*% betas + Z.i %*% b)\n        logY <- densLong(y[id.i], mu.y, sigma, log = TRUE)\n        log.p.yb <- sum(logY)\n        log.p.b <- densRE(b, mu = rep(0, ncz), D = D, log = TRUE, prop = FALSE)\n        st <- survMats.last[[ii]]$st\n        wk <- survMats.last[[ii]]$wk\n        P <- survMats.last[[ii]]$P\n        Xs <- survMats.last[[ii]]$Xs\n        Zs <- survMats.last[[ii]]$Zs\n        Xs.extra <- survMats.last[[ii]]$Xs.extra\n        Zs.extra <- survMats.last[[ii]]$Zs.extra\n        W2s <- survMats.last[[ii]]$W2s\n        ind <- survMats.last[[ii]]$ind\n        if (param %in% c(\"td-value\", \"td-both\"))\n            Ys <- transFun.value(as.vector(Xs %*% betas + Zs %*% b), data.s[ids.i, ])\n        if (param %in% c(\"td-extra\", \"td-both\"))\n            Ys.extra <- transFun.extra(as.vector(Xs.extra %*% betas[indFixed] + \n                                         Zs.extra %*% b[indRandom]), data.s[ids.i, ])\n        tt <- switch(param,\n            \"td-value\" = as.matrix(Ys) %*% alphas, \n            \"td-extra\" = as.matrix(Ys.extra) %*% Dalphas,\n            \"td-both\" = as.matrix(Ys) %*% alphas + as.matrix(Ys.extra) %*% Dalphas,\n            \"shared-betasRE\" = rep(sum((betas[indBetas] + b) * alphas), length(st)),        \n            \"shared-RE\" = rep(sum(b * alphas), length(st)))\n        eta.tw <- if (ncol(W)) {\n                as.vector(W[ii, , drop = FALSE] %*% gammas)\n        } else 0\n        Vi <- exp(c(W2s %*% Bs.gammas) + tt)\n        idT <- rep(seq_along(P), each = 15)\n        log.survival <- - sum(exp(eta.tw) * P * tapply(wk * Vi, idT, sum))\n        if (all(st == 0))\n            log.survival <- 1\n        logLik <- log.p.yb + log.survival + log.p.b\n        # Priors\n        priors <- object$priors\n        log.betas <- dmvnorm(betas, priors$priorMean.betas, \n            solve(priors$priorTau.betas), log = TRUE)\n        log.tau <- dgamma(1 / (sigma^2), priors$priorA.tau, \n            priors$priorB.tau, log = TRUE)\n        log.D <- dwish(solve(D), priors$priorR.invD, priors$priorK.invD, log = TRUE)\n        logPrior <- log.betas + log.tau + log.D\n        if (!is.null(gammas)) {\n            ind <- colSums(object$x$W == 0) == nrow(object$x$W)\n            log.gammas <- dmvnorm(gammas, priors$priorMean.gammas[!ind], \n                solve(priors$priorTau.gammas)[!ind, !ind], log = TRUE)\n            logPrior <- logPrior + log.gammas\n        }\n        if (!is.null(alphas)) {\n            log.alphas <- dmvnorm(alphas, priors$priorMean.alphas, \n                solve(priors$priorTau.alphas), log = TRUE)\n            logPrior <- logPrior + log.alphas\n        }\n        if (!is.null(Dalphas)) {\n            log.Dalphas <- dmvnorm(Dalphas, priors$priorMean.Dalphas, \n                solve(priors$priorTau.Dalphas), log = TRUE)\n            logPrior <- logPrior + log.Dalphas\n        }\n        if (baseHaz == \"regression-splines\") {\n            log.Bs.gammas <- dmvnorm(Bs.gammas, priors$priorMean.Bs.gammas, \n                                     solve(priors$priorTau.Bs.gammas), log = TRUE)\n            logPrior <- logPrior + log.Bs.gammas\n        } else {\n            log.Bs.gammas <- dmvnorm(Bs.gammas, priors$priorMean.Bs.gammas, \n                                     invSigma = tauBs * priors$priorTau.Bs.gammas, \n                                     log = TRUE)\n            log.tauBs <- dgamma(tauBs, priors$priorA.tauBs, \n                                priors$priorB.tauBs, log = TRUE)\n            logPrior <- logPrior + log.Bs.gammas + log.tauBs\n        }\n        - as.vector(logLik + logPrior)\n    }\n    score.logPost <- function (thetas.b, ii, transform = TRUE) {\n        fd(thetas.b, logPost, ii = ii, transform = transform)\n    }\n    w <- numeric(length(last.time))\n    con <- list(maxit = 200, parscale = rep(0.001, length(thetas.b)))\n    con[names(control)] <- control\n    for (i in seq_along(last.time)) {\n        w[i] <- tryCatch({\n            opt <- optim(thetas.b, logPost, score.logPost, ii = i, transform = TRUE, \n                method = method, control = con, hessian = TRUE)\n            opt.thetas <- relist(opt$par, list.thetas)\n            opt.thetas$sigma <- exp(opt.thetas$sigma)\n            opt.thetas$D <- chol.transf(opt.thetas$D)\n            opt.thetas$D <- opt.thetas$D[lower.tri(opt.thetas$D, TRUE)]\n            opt.thetas <- unlist(as.relistable(opt.thetas))\n            H <- opt$hessian\n            as.vector(0.5 * length(unlist(list.thetas)) * log(2 * pi) - \n                0.5 * determinant(H)$modulus - opt$value)\n        }, error = function (e) NA)\n    }\n    w\n}\n",
    "created" : 1452800352523.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1645902337",
    "id" : "E8EDDB5",
    "lastKnownWriteTime" : 1441113503,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/JMbayes/R/marglogLik.R",
    "project_path" : "R/marglogLik.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "type" : "r_source"
}