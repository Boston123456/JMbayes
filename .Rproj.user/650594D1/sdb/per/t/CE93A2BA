{
    "collab_server" : "",
    "contents" : "predict.JMbayes <- function (object, newdata, type = c(\"Marginal\", \"Subject\"),\n    interval = c(\"none\", \"confidence\", \"prediction\"), level = 0.95, idVar = \"id\", \n    FtTimes = NULL, last.time = NULL, LeftTrunc_var = NULL, M = 300, returnData = FALSE, \n    scale = 1.6, weight = rep(1, nrow(newdata)), invlink = NULL, seed = 1, ...) {\n    if (!inherits(object, \"JMbayes\"))\n        stop(\"Use only with 'JMbayes' objects.\\n\")\n    if (!is.data.frame(newdata) || nrow(newdata) == 0)\n        stop(\"'newdata' must be a data.frame with more than one rows.\\n\")\n    type <- match.arg(type)\n    interval <- match.arg(interval)\n    if (type == \"Marginal\") {\n        TermsX <- delete.response(object$Terms$termsYx)\n        mf <- model.frame(TermsX, data = newdata)\n        form <- reformulate(attr(TermsX, \"term.labels\"))\n        X <- model.matrix(form, data = mf)\n        out <- c(X %*% object$postMeans$betas)\n        if (!is.null(invlink))\n            out <- invlink(out)\n        names(out) <- row.names(newdata)\n        if (interval == \"prediction\") {\n            warning(\"\\nfor type = 'Marginal' only confidence intervals are calculated.\")\n            interval <- \"confidence\"\n        }\n        if (interval == \"confidence\") {\n            betas <- object$mcmc$betas\n            preds <- X %*% t(betas)\n            se.fit <- apply(preds, 1, sd)\n            alpha <- 1 - level\n            low <- apply(preds, 1, quantile, probs = alpha/2)\n            up <- apply(preds, 1, quantile, probs = 1 - alpha/2)\n            names(se.fit) <- names(low) <- names(up) <- row.names(newdata)\n            out <- list(pred = out, se.fit = se.fit, low = low, upp = up)\n            if (!is.null(invlink)) {\n                out$low <- invlink(out$low)\n                out$upp <- invlink(out$upp)\n            }\n        }\n        if (returnData) {\n            out <- if (is.list(out)) \n                cbind(newdata, do.call(cbind, out))\n            else\n                cbind(newdata, pred = out)\n        }\n    } else {\n        if (interval == \"prediction\" && !is.null(invlink)) {\n            interval <- \"confidence\"\n            warning(\"\\nprediction itervals are currently not calculated when 'invlink' is specified.\\n\")\n        }\n        if (is.null(newdata[[idVar]]))\n            stop(\"'idVar' not in 'newdata.\\n'\")\n        timeVar <- object$timeVar\n        df.RE <- object$y$df.RE\n        param <- object$param\n        densLong <- object$Funs$densLong\n        hasScale <- object$Funs$hasScale\n        anyLeftTrunc <- object$y$anyLeftTrunc\n        densRE <- object$Funs$densRE\n        transFun.value <- object$Funs$transFun.value\n        transFun.extra <- object$Funs$transFun.extra\n        extraForm <- object$Forms$extraForm\n        indFixed <- extraForm$indFixed\n        indRandom <- extraForm$indRandom\n        indBetas <- object$y$indBetas\n        TermsX <- object$Terms$termsYx\n        TermsZ <- object$Terms$termsYz\n        TermsX.extra <- object$Terms$termsYx.extra\n        TermsZ.extra <- object$Terms$termsYz.extra\n        mfX <- model.frame(TermsX, data = newdata)\n        mfZ <- model.frame(TermsZ, data = newdata)\n        formYx <- reformulate(attr(delete.response(TermsX), \"term.labels\"))\n        formYz <- object$Forms$formYz\n        estimateWeightFun <- object$estimateWeightFun\n        weightFun <- object$Funs$weightFun\n        max.time <- max(object$y$Time)\n        na.ind <- as.vector(attr(mfX, \"na.action\"))\n        na.ind <- if (is.null(na.ind)) {\n            rep(TRUE, nrow(newdata))\n        } else {\n            !seq_len(nrow(newdata)) %in% na.ind\n        }\n        id <- as.numeric(unclass(newdata[[idVar]]))\n        id <- id. <- match(id, unique(id))\n        id <- id[na.ind]\n        y <- model.response(mfX)\n        X <- model.matrix(formYx, mfX)\n        Z <- model.matrix(formYz, mfZ)[na.ind, , drop = FALSE]\n        TermsT <- object$Terms$termsT\n        data.id <- newdata[tapply(row.names(newdata), id, tail, n = 1L), ]\n        data.s <- data.id[rep(1:nrow(data.id), each = 15L), ]\n        idT <- data.id[[idVar]]\n        idT <- match(idT, unique(idT))\n        ids <- data.s[[idVar]]\n        ids <- match(ids, unique(ids))\n        mfT <- model.frame(delete.response(TermsT), data = data.id)        \n        formT <- if (!is.null(kk <- attr(TermsT, \"specials\")$cluster)) {\n            tt <- drop.terms(TermsT, kk - 1, keep.response = FALSE)\n            reformulate(attr(tt, \"term.labels\"))\n        } else {\n            tt <- attr(delete.response(TermsT), \"term.labels\")\n            if (length(tt)) reformulate(tt) else reformulate(\"1\")\n        }\n        W <- model.matrix(formT, mfT)[, -1, drop = FALSE]\n        obs.times <- split(newdata[[timeVar]], id.)\n        last.time <- if (is.null(last.time)) {\n            tapply(newdata[[timeVar]], id., tail, n = 1L)\n        } else if (is.numeric(last.time) && length(last.time) == nrow(data.id)) {\n            last.time\n        } else {\n            stop(\"\\nnot appropriate value for 'last.time' argument.\")\n        }\n        times <- object$Data$data[[timeVar]]\n        times.to.pred <- if (is.null(FtTimes)) {\n            lapply(last.time, \n                function (t) seq(t, max(times) + 0.1 * mad(times), length = 25L))\n        } else {\n            if (!is.list(FtTimes) || length(FtTimes) != length(last.time))\n                rep(list(FtTimes), length(last.time))\n            else\n                FtTimes\n        }\n        TimeL <- if (!is.null(anyLeftTrunc) && anyLeftTrunc) {\n            if (is.null(LeftTrunc_var) || is.null(newdata[[LeftTrunc_var]])) {\n                warning(\"The original joint model was fitted in a data set with left-\",\n                        \"truncation and\\nargument 'LeftTrunc_var' of predict.JMbayes() has not \", \n                        \"been specified.\\n\")\n            }\n            TimeL <- newdata[[LeftTrunc_var]]\n            tapply(TimeL, id, head, n = 1)\n        }\n        n <- length(object$y$Time)\n        n.tp <- length(last.time)\n        ncx <- ncol(X)\n        ncz <- ncol(Z)\n        ncww <- ncol(W)\n        if (ncww == 0)\n            W <- NULL\n        lag <- object$y$lag\n        betas <- object$postMeans$betas\n        sigma <- object$postMeans$sigma\n        D <- object$postMeans$D\n        gammas <- object$postMeans$gammas\n        alphas <- object$postMeans$alphas\n        Dalphas <- object$postMeans$Dalphas\n        shapes <- object$postMeans$shapes\n        Bs.gammas <- object$postMeans$Bs.gammas\n        list.thetas <- list(betas = betas, sigma = sigma, gammas = gammas, \n                            alphas = alphas, Dalphas = Dalphas, shapes = shapes, \n                            Bs.gammas = Bs.gammas, D = D)\n        list.thetas <- list.thetas[!sapply(list.thetas, is.null)]\n        thetas <- unlist(as.relistable(list.thetas))\n        Var.thetas <- vcov(object)\n        environment(log.posterior.b) <- environment(ModelMats) <- environment()\n        # construct model matrices to calculate the survival functions\n        obs.times.surv <- split(data.id[[timeVar]], idT)\n        survMats.last <- vector(\"list\", n.tp)\n        for (i in seq_len(n.tp)) {\n            survMats.last[[i]] <- ModelMats(last.time[i], ii = i)\n        }\n        data.id2 <- newdata[tapply(row.names(newdata), id, tail, n = 1L), ]\n        data.id2 <- data.id2[rep(1:nrow(data.id2), \n            sapply(times.to.pred, length)), ]\n        data.id2[[timeVar]] <- unlist(times.to.pred)\n        mfXpred <- model.frame(TermsX, data = data.id2)\n        mfZpred <- model.frame(TermsZ, data = data.id2)\n        Xpred <- model.matrix(formYx, mfXpred)\n        Zpred <- model.matrix(formYz, mfZpred)\n        id2 <- as.numeric(unclass(data.id2[[idVar]]))\n        id2 <- match(id2, unique(id2))\n        # calculate the Empirical Bayes estimates and their (scaled) variance\n        modes.b <- matrix(0, n.tp, ncz)\n        invVars.b <- Vars.b <- vector(\"list\", n.tp)\n        set.seed(seed)\n        for (i in seq_len(n.tp)) {\n            betas.new <- betas\n            sigma.new <- sigma\n            D.new <- D\n            gammas.new <- gammas\n            alphas.new <- alphas\n            Dalphas.new <- Dalphas\n            shapes.new <- shapes\n            Bs.gammas.new <- Bs.gammas\n            ff <- function (b, y, tt, mm, i) \n                -log.posterior.b(b, y, Mats = tt, ii = i)\n            opt <- try(optim(rep(0, ncz), ff, y = y, tt = survMats.last, i = i, \n                method = \"BFGS\", hessian = TRUE), TRUE)\n            if (inherits(opt, \"try-error\")) {\n                gg <- function (b, y, tt, mm, i) cd(b, ff, y = y, tt = tt, i = i)\n                opt <- optim(rep(0, ncz), ff, gg, y = y, tt = survMats.last,\n                    i = i, method = \"BFGS\", hessian = TRUE)\n            }\n            modes.b[i, ] <- opt$par\n            invVars.b[[i]] <- opt$hessian/scale\n            Vars.b[[i]] <- scale * solve(opt$hessian)        \n        }\n        res <- vector(\"list\", M)\n        success.rate <- matrix(FALSE, M, n.tp)\n        b.old <- b.new <- modes.b\n        if (n.tp == 1)\n            dim(b.old) <- dim(b.new) <- c(1L, ncz)    \n        mcmc <- object$mcmc\n        mcmc <- mcmc[names(mcmc) != \"b\"]\n        if (M > nrow(mcmc$betas)) {\n            warning(\"'M' cannot be set greater than \", nrow(mcmc$betas))\n            M <- nrow(mcmc$betas)\n            out <- vector(\"list\", M)\n            success.rate <- matrix(FALSE, M, n.tp)\n        }\n        samples <- sample(nrow(mcmc$betas), M)\n        mcmc[] <- lapply(mcmc, function (x) x[samples, , drop = FALSE])\n        proposed.b <- mapply(rmvt, mu = split(modes.b, row(modes.b)), Sigma = Vars.b, \n                             MoreArgs = list(n = M, df = 4), SIMPLIFY = FALSE)\n        dmvt.proposed <- mapply(dmvt, x = proposed.b, mu = split(modes.b, row(modes.b)),\n                                Sigma = Vars.b, MoreArgs = list(df = 4, log = TRUE), SIMPLIFY = FALSE)\n        for (m in 1:M) {\n            # Step 1: simulate new parameter values\n            betas.new <- mcmc$betas[m, ]\n            if (hasScale)\n                sigma.new <- mcmc$sigma[m, ]\n            if (!is.null(W))\n                gammas.new <- mcmc$gammas[m, ]\n            if (param %in% c(\"td-value\", \"td-both\", \"shared-betasRE\", \"shared-RE\")) \n                alphas.new <- mcmc$alphas[m, ]\n            if (param %in% c(\"td-extra\", \"td-both\"))\n                Dalphas.new <- mcmc$Dalphas[m, ]\n            if (estimateWeightFun)\n                shapes.new <- mcmc$shapes[m, ]\n            D.new <- mcmc$D[m, ]; dim(D.new) <- dim(D)\n            Bs.gammas.new <- mcmc$Bs.gammas[m, ]\n            y.new <- vector(\"list\", n.tp)\n            for (i in seq_len(n.tp)) {\n                # Step 2: simulate new random effects values\n                p.b <- proposed.b[[i]][m, ]\n                dmvt.old <- dmvt(b.old[i, ], modes.b[i, ], invSigma = invVars.b[[i]], df = 4, log = TRUE)\n                dmvt.prop <- dmvt.proposed[[i]][m]\n                a <- min(exp(log.posterior.b(p.b, y, survMats.last, ii = i) + dmvt.old - \n                        log.posterior.b(b.old[i, ], y, survMats.last, ii = i) - dmvt.prop), 1)\n                ind <- runif(1) <= a\n                success.rate[m, i] <- ind\n                if (!is.na(ind) && ind)\n                    b.new[i, ] <- p.b\n                # Step 3: compute future Ys\n                Xpred.i <- Xpred[id2 == i, , drop = FALSE]\n                Zpred.i <- Zpred[id2 == i, , drop = FALSE]                \n                mu.i <- as.vector(c(Xpred.i %*% betas.new) + \n                    rowSums(Zpred.i * rep(b.new[i, ], each = nrow(Zpred.i))))\n                if (!is.null(invlink))\n                    mu.i <- invlink(mu.i)\n                y.new[[i]] <- if (interval == \"confidence\") weight[i] * mu.i else \n                    if (interval == \"prediction\") {\n                            weight[i] * rnorm(length(mu.i), mu.i, sigma.new)\n                    }\n            }\n            b.old <- b.new\n            res[[m]] <- y.new\n        }\n        oo <- vector(\"list\", n.tp)\n        for (i in seq_len(n.tp)) {\n            oo[[i]] <- do.call(rbind, sapply(res, \"[\", i))\n        }\n        out <- as.vector(c(Xpred %*% betas) + rowSums(Zpred * modes.b[id2, , drop = FALSE]))\n        if (!is.null(invlink))\n            out <- invlink(out)\n        out <- weight[i] * out\n        if (interval %in% c(\"confidence\", \"prediction\")) {\n            alpha <- 1 - level\n            se.fit <- lapply(oo, function (m) apply(as.matrix(m), 2, sd))\n            f1 <- function (mat) apply(mat, 2, quantile, probs = alpha/2)\n            f2 <- function (mat) apply(mat, 2, quantile, probs = 1 - alpha/2)\n            low <- lapply(oo, f1) \n            up <- lapply(oo, f2)\n            out <- list(pred = out, se.fit = unlist(se.fit), \n                low = unlist(low), upp = unlist(up), all.vals = oo)\n            if (!is.null(invlink)) {\n                out$low <- invlink(out$low)\n                out$upp <- invlink(out$upp)\n            }\n        }\n        if (returnData) {\n            newdata$pred <- c(X %*% betas) + rowSums(Z * modes.b[id, ])\n            out <- if (is.list(out)) {\n                newdata$upp <- newdata$low <- newdata$se.fit <- NA\n                rbind(newdata, cbind(data.id2, do.call(cbind, out[-5])))\n            } else {\n                rbind(newdata, cbind(data.id2, pred = out))\n            }\n        } else\n            attr(out, \"time.to.pred\") <- times.to.pred\n    }\n    rm(list = \".Random.seed\", envir = globalenv())\n    class(out) <- c(class(out), \"predict.JMbayes\")\n    out\n}\n",
    "created" : 1463644215157.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3660895601",
    "id" : "CE93A2BA",
    "lastKnownWriteTime" : 1463650203,
    "last_content_update" : 1463650203508,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/JMbayes/R/predict.JMbayes.R",
    "project_path" : "R/predict.JMbayes.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}