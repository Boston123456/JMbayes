{
    "collab_server" : "",
    "contents" : "jointModelBayes <- function (lmeObject, survObject, timeVar,\n                             param = c(\"td-value\", \"td-extra\", \"td-both\", \"shared-betasRE\", \"shared-RE\"),\n                             extraForm = NULL, baseHaz = c(\"P-splines\", \"regression-splines\"), \n                             transFun = NULL, densLong = NULL, lag = 0, df.RE = NULL,\n                             estimateWeightFun = FALSE, weightFun = NULL, init = NULL, priors = NULL, scales = NULL, \n                             control = list(), ...) {\n    cl <- match.call()\n    param <- match.arg(param)\n    baseHaz <- match.arg(baseHaz)\n    if (!inherits(lmeObject, \"lme\"))\n        stop(\"\\n'lmeObject' must inherit from class lme.\")\n    if (length(lmeObject$group) > 1)\n        stop(\"\\nnested random-effects are not allowed in lme().\")\n    if (!is.null(lmeObject$modelStruct$corStruct))\n        warning(\"correlation structure in 'lmeObject' is ignored.\\n\")\n    if (!inherits(survObject, \"coxph\"))\n        stop(\"\\n'survObject' must inherit from class coxph.\")\n    if (is.null(survObject$x))\n        stop(\"\\nuse argument 'x = TRUE' in coxph().\")\n    if (length(timeVar) != 1L || !is.character(timeVar))\n        stop(\"\\n'timeVar' must be a character string.\")\n    if (param %in% c(\"td-extra\", \"td-both\") && is.null(extraForm)) {\n        stop(\"\\nwhen parameterization is 'td-extra' or 'td-both' you need to specify the 'extraForm' argument.\")\n    }\n    if (!param %in% c(\"td-extra\", \"td-both\") && !is.null(extraForm)) {\n        stop(\"\\nyou have defined 'extraForm' but the parameterization is neither 'td-extra' nor 'td-both'.\")\n    }\n    if (param %in% c(\"td-extra\", \"td-both\") && !is.list(extraForm)) {\n        stop(\"\\nthe 'extraForm' argument must be a list with components 'fixed' (a formula),\\n\\t'indFixed'\",\n             \"(a numeric vector), 'random' (a formula) and 'indRandom' (a numeric vector).\")\n    }\n    # extract response & design matrix survival process\n    formT <- formula(survObject)\n    W <- survObject$x\n    if (!length(W))\n        W <- NULL\n    SurvInf <- survObject$y\n    typeSurvInf <- attr(SurvInf, \"type\")\n    if (typeSurvInf == \"right\") {\n        Time <- SurvInf[, \"time\"]\n        Time[Time < 1e-04] <- 1e-04\n        nT <- length(Time)\n        event <- SurvInf[, \"status\"]\n        LongFormat <- FALSE\n    }\n    if (typeSurvInf == \"counting\") {\n        if (is.null(survObject$model))\n            stop(\"\\nplease refit the Cox model including in the \", \n                 \"call to coxph() the argument 'model = TRUE'.\")\n        idT <- if (!is.null(survObject$model$cluster)) {\n            as.vector(unclass(survObject$model$cluster))\n        } else {\n            seq_len(nrow(survObject$model))\n        }\n        strata <- if (!is.null(survObject$model$strata)) {\n            as.vector(unclass(survObject$model$strata))\n        } else {\n            seq_len(nrow(survObject$model))\n        }\n        idT <- match(idT, unique(idT))\n        LongFormat <- length(idT) > length(unique(idT))\n        TimeL <- TimeLl <- SurvInf[, \"start\"]\n        TimeL <- tapply(TimeL, idT, head, n = 1)\n        anyLeftTrunc <- any(TimeL > 1e-07)\n        TimeR <- SurvInf[, \"stop\"]\n        TimeR[TimeR < 1e-04] <- 1e-04\n        Time <- tapply(TimeR, idT, tail, n = 1)\n        nT <- length(Time)\n        eventLong <- SurvInf[, \"status\"]\n        event  <- tapply(eventLong, idT, tail, n = 1)\n    }\n    # longitudinal process\n    idOrig <- lmeObject$groups[[1L]]\n    id <- as.vector(unclass(idOrig))\n    b <- data.matrix(ranef(lmeObject))\n    dimnames(b) <- NULL\n    nY <- nrow(b)\n    if (nY != nT)\n        stop(\"sample sizes in the longitudinal and event processes differ.\\n\")\n    data <- lmeObject$data\n    if (!timeVar %in% names(data))\n        stop(\"\\n'timeVar' does not correspond to one of the columns in the model.frame of the 'lmeObject'.\")\n    times <- data[[timeVar]]\n    # check if there are any longitudinal measurements after the event times\n    max.timeY <- tapply(times, id, max)\n    if (!all(Time >= max.timeY)) {\n        idnams <- factor(idOrig)\n        stop(\"\\nit seems that there are longitudinal measurements taken after the event times for some subjects \",\n             \"(i.e., check subject(s): \", paste(levels(idnams)[(Time < max.timeY)], collapse = \", \"), \").\")\n    }\n    formYx <- formula(lmeObject)\n    mfX <- model.frame(terms(formYx), data = data)\n    TermsX <- attr(mfX, \"terms\")\n    X <- model.matrix(formYx, mfX)\n    offset <- model.offset(mfX)\n    formYz <- formula(lmeObject$modelStruct$reStruct[[1]])\n    mfZ <- model.frame(terms(formYz), data = data)\n    TermsZ <- attr(mfZ, \"terms\")\n    Z <- model.matrix(formYz, mfZ)\n    y.long <- model.response(mfX, \"numeric\")\n    long <- c(X %*% fixef(lmeObject)) + rowSums(Z * b[id, ])    \n    if (densLongCheck <- is.null(densLong)) {\n        if (is.null(lmeObject$family)) {\n            densLong <- function (y, eta.y, scale, log = FALSE, data) {\n                dnorm(x = y, mean = eta.y, sd = scale, log = log)\n            }\n        } else {\n            stop(\"you should define 'densLong' appropriately.\\n\")\n        }\n    } else {\n        if (!is.function(densLong) || \n                !names(formals(densLong)) %in% c(\"y\", \"eta.y\", \"scale\", \"log\", \"data\"))\n            stop(\"invalid specification of densLong(); check the help file.\")\n    }\n    # density of the random effects\n    densRE <- if (is.null(df.RE)) {\n        function (b, mu, D = NULL, invD = NULL, log = FALSE, prop = TRUE) {\n            dmvnorm(b, mu = mu, Sigma = D, invSigma = invD, log = log,\n                    prop = prop)\n        }\n    } else {\n        ddRE <- function (b, mu = NULL, D = NULL, invD = NULL, log = FALSE, df, prop = TRUE) {\n            if (is.null(mu)) {\n                nn <- if (is.matrix(b)) ncol(b) else length(b)\n                mu <- numeric(nn)\n            }\n            dmvt(b, mu = mu, Sigma = D, invSigma = invD, df = df, log = log, \n                 prop = prop)\n        }\n        formals(ddRE)$\"df\" <- df.RE\n        ddRE\n    }\n    # posterior variances random effects\n    D <- lapply(pdMatrix(lmeObject$modelStruct$reStruct), \"*\",\n                lmeObject$sigma^2)[[1]]\n    invD <- solve(D)\n    sigma <- lmeObject$sigma\n    sigma2 <- sigma * sigma    \n    if (densLongCheck && is.null(df.RE)) {\n        Cov.postRE <- vector(\"list\", nY)\n        for (i in seq_len(nY)) {\n            Z.i <- Z[id == i, , drop = FALSE]\n            Cov.postRE[[i]] <- solve.default(crossprod(Z.i) / sigma2 + invD)\n        }\n    } else {\n        betas <- fixef(lmeObject)\n        logpostRE <- function (b) {\n            eta.yi <- drop(X.i %*% betas) + drop(Z.i %*% b)\n            dY <- densLong(y.i, eta.yi, scale = sigma, log = TRUE, data[id.i, , drop = FALSE])\n            dRE <- densRE(b, mu = rep(0, ncol(Z.i)), invD = invD, log = TRUE)\n            - sum(dY, dRE, na.rm = TRUE)\n        }\n        Cov.postRE <- vector(\"list\", nY)\n        for (i in seq_len(nY)) {\n            id.i <- id == i\n            y.i <- y.long[id.i]\n            X.i <- X[id.i, , drop = FALSE]\n            Z.i <- Z[id.i, , drop = FALSE]\n            opt <- optim(b[i, ], logpostRE, method = \"BFGS\", hessian = TRUE)\n            b[i, ] <- opt$par\n            Cov.postRE[[i]] <- solve(opt$hessian)\n        }\n    }\n    # check parameterization and hierarchical centering\n    check_names <- all(colnames(Z) %in% colnames(X))\n    if (check_names) {\n        performHC <- max(diag(D)) > sigma2 / nY && is.null(df.RE)\n        has_interceptX <- attr(TermsX, \"intercept\")\n        has_interceptZ <- attr(TermsZ, \"intercept\")\n        performHC <- performHC && has_interceptX && (has_interceptX == has_interceptZ)\n        indBetas <- if (performHC) {\n            terms.labs_X <- attr(TermsX, \"term.labels\")\n            terms.labs_Z <- attr(TermsZ, \"term.labels\")\n            # check for time-varying covariates\n            timeTerms <- grep(timeVar, colnames(X), fixed = TRUE)\n            which_td <- unname(which(apply(X, 2, check_td, id = id)))\n            all_TDterms <- unique(c(timeTerms, which_td))\n            baseline <- seq_len(ncol(X))[-all_TDterms]\n            #factorsX <- attr(TermsX, \"factors\")           \n            c(list(baseline), lapply(colnames(Z)[-1L], find_positions, \n                                     nams2 = colnames(X)))\n        }\n    } else {\n        performHC <- FALSE\n        if (param == \"shared-betasRE\") {\n            warning(\"\\nit seems that the random effects design matrix is not a subset of the \",\n                    \"fixed effects design matrix. Argument 'param' is set to 'shared-RE'.\")\n            param <- \"shared-RE\"\n        }\n    }\n    if (check_names && param == \"shared-betasRE\") {\n        indBetasRE <- match(colnames(Z), colnames(X))\n    }\n    # transormation functions\n    if (is.null(transFun)) {\n        transFun.value <- function (x, data) x\n        transFun.extra <- function (x, data) x\n    } else {\n        if (is.function(transFun)) {\n            transFun.value <- transFun.extra <- transFun\n        }\n        if (is.list(transFun)) {\n            transFun.value <- transFun$value\n            transFun.extra <- transFun$extra\n        }\n        if (any(!names(formals(transFun.value)) %in% c(\"x\", \"data\")))\n            stop(\"\\nincorrect specification of 'transFun' arguments.\")\n        if (any(!names(formals(transFun.extra)) %in% c(\"x\", \"data\")))\n            stop(\"\\nincorrect specification of 'transFun' arguments.\")\n    }\n    # put functions in a list\n    hasScale <- inherits(try(densLong(y = y.long[1L], eta.y = lmeObject$fitted[1L], \n                                      log = FALSE, data = data), \n                             silent = TRUE), \"try-error\")\n    Funs <- list(transFun.value = transFun.value, transFun.extra = transFun.extra,\n                 densRE = densRE, densLong = densLong, hasScale = hasScale)\n    # control values\n    con <- list(adapt = FALSE, n.iter = 20000L, n.burnin = 3000L, n.thin = 10L, \n                n.adapt = 3000L, keepRE = TRUE, n.batch = 100L, priorVar = 100, \n                performHC = performHC, robust_baseHaz = FALSE, rescale_Bs.gammas = TRUE,\n                knots = NULL, ObsTimes.knots = TRUE, \n                lng.in.kn = if (baseHaz == \"P-splines\") 15L else 5L, ordSpline = 4L, \n                seed = 1L, diff = 2L, \n                GQsurv = if (!estimateWeightFun) \"GaussKronrod\" else \"GaussLegendre\", \n                GQsurv.k = if (!estimateWeightFun) 15L else 17L,\n                priorShapes = list(shape1 = dnorm, shape2 = dgamma, shape3 = dunif),\n                verbose = TRUE, verbose2 = FALSE)\n    control <- c(control, list(...))\n    namC <- names(con)\n    con[(namc <- names(control))] <- control\n    if (!any(namc == \"n.thin\"))\n        con$n.thin <- max(1, floor(con$n.iter / 2000))\n    if (length(noNms <- namc[!namc %in% namC]) > 0)\n        warning(\"unknown names in control: \", paste(noNms, collapse = \", \"))\n    # construct desing matrices for longitudinal part for the hazard function\n    data.id <- data[!duplicated(id), ]\n    data.id[[timeVar]] <- pmax(Time - lag, 0)\n    if (param %in% c(\"td-value\", \"td-both\")) {\n        mfX.id <- model.frame(TermsX, data = data.id)\n        mfZ.id <- model.frame(TermsZ, data = data.id)\n        Xtime <- model.matrix(formYx, mfX.id)\n        Ztime <- model.matrix(formYz, mfZ.id)\n    }\n    if (param %in% c(\"td-extra\", \"td-both\")) {\n        mfX.extra <- model.frame(terms(extraForm$fixed), data = data)\n        TermsX.extra <- attr(mfX.extra, \"terms\")\n        mfZ.extra <- model.frame(terms(extraForm$random), data = data)\n        TermsZ.extra <- attr(mfZ.extra, \"terms\")\n        mfX.extra.id <- model.frame(TermsX.extra, data = data.id)\n        mfZ.extra.id <- model.frame(TermsZ.extra, data = data.id)\n        Xtime.extra <- model.matrix(extraForm$fixed, mfX.extra.id)\n        Ztime.extra <- model.matrix(extraForm$random, mfZ.extra.id)\n        Xextra <- model.matrix(extraForm$fixed, mfX.extra)\n        Zextra <- model.matrix(extraForm$random, mfZ.extra)\n        long.extra <- as.vector(c(Xextra %*% fixef(lmeObject)[extraForm$indFixed]) +\n            if (all(extraForm$indRandom > 0)) {\n                rowSums(Zextra * b[id, extraForm$indRandom, drop = FALSE])\n            } else {\n                rep(0, nrow(Zextra))\n            })\n    }\n    if (param == \"td-value\" || param == \"shared-betasRE\" || param == \"shared-RE\")\n        long.extra <- NULL\n    if (param == \"td-extra\")\n        long <- NULL\n    if (performHC) {\n        data.idHC <- data.id\n        data.idHC[[timeVar]] <- 1\n        mfHC <- model.frame(TermsX, data = data.idHC)\n        which.timeVar <- grep(timeVar, names(mfHC), fixed = TRUE)\n        mfHC[which.timeVar] <- lapply(mfHC[which.timeVar], function (x) { x[] <- 1; x })\n        XXtime <- model.matrix(formYx, mfHC)\n    }\n    # response vectors and design matrices\n    y <- list(y = y.long, Time = Time, event = event, lag = lag, df.RE = df.RE, id = id,\n              indBetas = if (check_names) indBetas, \n              indBetasRE = if (param == \"shared-betasRE\") indBetasRE, \n              LongFormat = LongFormat, offset = offset)\n    if (typeSurvInf == \"counting\")\n        y <- c(y, list(TimeL = TimeL, TimeR = TimeR, eventLong = eventLong, idT = idT,\n                       typeSurvInf = typeSurvInf, anyLeftTrunc = anyLeftTrunc))\n    x <- list(X = X, Z = Z, W = W)\n    if (typeSurvInf == \"counting\") {\n        wind <- tapply(idT, idT, function (x) rep(c(FALSE, TRUE), c(length(x) - 1, 1)))\n        x$W <- x$W[unlist(wind, use.names = FALSE), , drop = FALSE]\n    }\n    x <- switch(param,\n                \"td-value\" = c(x, list(Xtime = Xtime, Ztime = Ztime)),\n                \"td-extra\" = c(x, list(Xtime.extra = Xtime.extra, Ztime.extra = Ztime.extra)),\n                \"td-both\" = c(x, list(Xtime = Xtime, Ztime = Ztime,\n                                      Xtime.extra = Xtime.extra, Ztime.extra = Ztime.extra)),\n                \"shared-betasRE\" =, \"shared-RE\" =  x)\n    if (performHC) {\n        x <- c(x, list(XXtime = XXtime))\n    }\n    # construct desing matrices for longitudinal part for the survival function\n    GQsurv <- if (con$GQsurv == \"GaussKronrod\") gaussKronrod() else gaussLegendre(con$GQsurv.k)\n    wk <- GQsurv$wk\n    sk <- GQsurv$sk\n    K <- length(sk)\n    P <- if (typeSurvInf == \"counting\" && anyLeftTrunc) (Time - TimeL) / 2 else Time / 2\n    st <- if (typeSurvInf == \"counting\" && anyLeftTrunc) {\n        outer(P, sk) + c(Time + TimeL) / 2\n    } else {\n        outer(P, sk + 1)\n    }\n    id.GK <- rep(seq_along(Time), each = K)\n    data.id2 <- data.id[id.GK, ]\n    data.id2[[timeVar]] <- pmax(c(t(st)) - lag, 0)\n    y <- c(y, list(id.GK = id.GK))\n    x <- c(x, list(P = P, st = st, wk = wk))\n    if (param %in% c(\"td-value\", \"td-both\")) {\n        mfX <- model.frame(TermsX, data = data.id2)\n        mfZ <- model.frame(TermsZ, data = data.id2)\n        Xs <- model.matrix(formYx, mfX)\n        Zs <- model.matrix(formYz, mfZ)\n        x <- c(x, list(Xs = Xs, Zs = Zs))\n        if (estimateWeightFun) {\n            P2 <- c(t(st)) / 2\n            st2 <- outer(P2, sk + 1)\n            id.GK2 <- rep(seq_len(nrow(data.id2)), each = K)\n            data.id3 <- data.id2[id.GK2, ]\n            data.id3[[timeVar]] <- pmax(c(t(st2)) - lag, 0)\n            mfX <- model.frame(TermsX, data = data.id3)\n            mfZ <- model.frame(TermsZ, data = data.id3)\n            Xu <- model.matrix(formYx, mfX)\n            Zu <- model.matrix(formYz, mfZ)\n            x <- c(x, list(Xu = Xu, Zu = Zu, P2 = P2, st2 = st2))\n            y <- c(y, list(id.GK2 = id.GK2))\n            if (is.null(weightFun) || !is.function(weightFun)) {\n                weightFun <- function (u, parms, t.max) {\n                    num <- dnorm(x = u, mean = parms[1L], sd = parms[2L])\n                    den <- pnorm(q = c(0, t.max), mean = parms[1L], sd = parms[2L])\n                    num / (den[2L] - den[1L])\n                }\n            }\n            Funs <- c(Funs, list(weightFun = weightFun))\n        }\n    }\n    if (param %in% c(\"td-extra\", \"td-both\")) {\n        mfX.extra <- model.frame(TermsX.extra, data = data.id2)\n        mfZ.extra <- model.frame(TermsZ.extra, data = data.id2)\n        Xs.extra <- model.matrix(extraForm$fixed, mfX.extra)\n        Zs.extra <- model.matrix(extraForm$random, mfZ.extra)\n        x <- c(x, list(Xs.extra = Xs.extra, Zs.extra = Zs.extra))\n    }\n    # extra design matrices for the log approximated baseline hazard\n    kn <- if (is.null(con$knots)) {\n        if (baseHaz == \"P-splines\") {\n            tt <- if (con$ObsTimes.knots) Time else Time[event == 1]\n            pp <- quantile(tt, c(0.05, 0.95), names = FALSE)\n            tail(head(seq(pp[1L], pp[2L], length.out = con$lng.in.kn), -1), -1)\n        } else {\n            pp <- seq(0, 1, length.out = con$lng.in.kn + 2)\n            pp <- tail(head(pp, -1), -1)\n            tt <- if (con$ObsTimes.knots) Time else Time[event == 1]\n            quantile(tt, pp, names = FALSE)            \n        }\n    } else {\n        con$knots\n    }\n    kn <- kn[kn < max(Time)]\n    rr <- sort(c(rep(range(Time, st), con$ordSpline), kn))\n    con$knots <- rr\n    W2 <- splineDesign(rr, Time, ord = con$ordSpline)\n    if (any(colSums(W2) == 0))\n        stop(\"\\nsome of the knots of the B-splines basis are set outside the range\",\n             \"\\nof the observed event times.\")\n    W2s <- splineDesign(rr, c(t(st)), ord = con$ordSpline)\n    if (typeSurvInf == \"counting\" && LongFormat) {\n        TDind <- mapply(findInterval, x = split(st, row(st)), vec = split(TimeLl, idT), \n                        SIMPLIFY = FALSE)\n        Ws <- do.call(rbind, mapply(function (x, i) x[i, , drop = FALSE], i = TDind,\n                                    x = lapply(split(W, idT), matrix, ncol = ncol(W)), \n                                    SIMPLIFY = FALSE))\n    } else {\n        Ws <- NULL\n    }\n    x <- c(x, list(Ws = Ws, W2 = W2, W2s = W2s))\n    # All data\n    Data <- list(data = data, data.id = data.id, data.s = data.id2, \n                 data.u = if (estimateWeightFun) data.id3)\n    # extract initial values\n    D <- lapply(pdMatrix(lmeObject$modelStruct$reStruct), \"*\",\n                 lmeObject$sigma^2)[[1]]\n    sigma2 <- lmeObject$sigma^2\n    initial.values <- list(betas = fixef(lmeObject), tau = 1/sigma2, b = b,\n                           D = D, invD = invD)\n    initSurv <- initSurvival(Time, event, id, W2, W2s, P, wk, id.GK, times, \n                             b, initial.values$betas, y$indBetas, \n                             x$W, baseHaz, con$diff, Data, param, \n                             if (param %in% c(\"td-value\", \"td-both\")) long else NULL, \n                             long.extra, transFun.value, transFun.extra, \n                             vl = if (param %in% c(\"td-value\", \"td-both\")) \n                                 transFun.value(c(Xtime %*% fixef(lmeObject)) + \n                                                    rowSums(Ztime * b), Data$data.id),\n                             vls = if (param %in% c(\"td-value\", \"td-both\")) \n                                 transFun.value(c(Xs %*% fixef(lmeObject)) + \n                                                    rowSums(Zs * b[id.GK, , drop = FALSE]), Data$data.s),\n                             ex = if (param %in% c(\"td-extra\", \"td-both\")) {\n                                 iF <- extraForm$indFixed; iR <- extraForm$indRandom\n                                 transFun.extra(c(Xtime.extra %*% fixef(lmeObject)[iF]) + \n                                                    rowSums(Ztime.extra * b[, iR, drop = FALSE]), Data$data.id)\n                             },\n                             exs = if (param %in% c(\"td-extra\", \"td-both\")) {\n                                 iF <- extraForm$indFixed; iR <- extraForm$indRandom\n                                 transFun.extra(c(Xs.extra %*% fixef(lmeObject)[iF]) + \n                                                    rowSums(Zs.extra * b[id.GK, iR, drop = FALSE]), Data$data.s)\n                             })\n    initial.values$gammas <- initSurv$gammas\n    initial.values$Bs.gammas <- initSurv$Bs.gammas\n    initial.values$tauBs <- initSurv$tauBs\n    initial.values$deltaBs <- 0.005\n    initial.values$alphas <- initSurv$alphas\n    initial.values$Dalphas <- initSurv$Dalphas\n    if (estimateWeightFun) {\n        w1 <- try(weightFun(0.1, c(0.1), 1), TRUE)\n        w2 <- try(weightFun(0.1, c(0.1, 0.1), 1), TRUE)\n        w3 <- try(weightFun(0.1, c(0.1, 0.1, 0.1), 1), TRUE)\n        ind1 <- inherits(w1, \"try-error\") || is.na(w1)\n        ind2 <- inherits(w2, \"try-error\") || is.na(w2)\n        ind3 <- inherits(w3, \"try-error\") || is.na(w3)\n        nshapes <- if (ind1 && ind2) {\n            3\n        } else if (ind2 || (!ind1 && w1 == w2)) {\n            1\n        } else if (ind3 || (!ind2 && w2 == w3)) {\n            2\n        } else 3\n        initial.values$shapes <- rep(0.1, nshapes)\n    }\n    initial.values <- initial.values[!sapply(initial.values, is.null)]\n    if (!is.null(init)) {\n        lngths <- lapply(initial.values[(nam.init <- names(init))], length)\n        if (!is.list(init) || !isTRUE(all.equal(lngths, lapply(init, length)))) {\n            warning(\"'init' is not a list with elements numeric vectors of appropriate \",\n                    \"length; default starting values are used instead.\\n\")\n        } else {\n            initial.values[nam.init] <- init\n            if (!is.matrix(initial.values$b))\n                dim(initial.values$b) <- dim(b)\n            if (!is.matrix(initial.values$D))\n                dim(initial.values$D) <- dim(initial.values$invD) <- dim(D)            \n        }\n    }\n    # default priors\n    prs <- list(priorMean.betas = numeric(ncol(X)), \n                priorTau.betas = diag(1 / con$priorVar, ncol(X)),\n                priorA.tau = (1/sigma2)^2 / 10, priorB.tau = (1/sigma2) / 10,\n                priorR.invD = ncol(Z) * invD, priorK.invD = ncol(Z),\n                priorMean.Bs.gammas = numeric(ncol(W2)), \n                priorTau.Bs.gammas = diag(10 / con$priorVar, ncol(W2)))\n    if (baseHaz == \"P-splines\") {\n        DD <- diag(ncol(W2))\n        prs$priorTau.Bs.gammas <- crossprod(diff(DD, differences = con$diff)) + 1e-06 * DD\n        #prs$priorA.tauBs <- 1\n        #prs$priorB.tauBs <- 0.005\n        prs$priorA.tauBs <- 1\n        prs$priorB.tauBs <- if (con$robust_baseHaz) 1 else 0.005\n        prs$priorA.deltaBs <- 1e-02\n        prs$priorB.deltaBs <- 1e-02\n    }\n    if (!is.null(W)) {\n        prs$priorMean.gammas <- numeric(ncol(W))\n        prs$priorTau.gammas <- drop(diag(1 / con$priorVar, ncol(W)))\n    }\n    if (param %in% c(\"td-value\", \"td-both\", \"shared-betasRE\", \"shared-RE\")) {\n        prs$priorMean.alphas <- numeric(length(initial.values$alphas))\n        prs$priorTau.alphas <- drop(diag(10 / con$priorVar, length(initial.values$alphas)))\n    }\n    if (param %in% c(\"td-extra\", \"td-both\")) {\n        prs$priorMean.Dalphas <- numeric(length(initial.values$Dalphas))\n        prs$priorTau.Dalphas <- drop(diag(10 / con$priorVar, length(initial.values$Dalphas)))\n    }\n    if (estimateWeightFun) {\n        maxT <- max(Time) * 0.7\n        prs$priorshape1 <- c(0, 5)\n        prs$priorshape2 <- c(0.1, 0.1)\n        prs$priorshape3 <- c(-maxT, maxT)\n    }\n    if (!is.null(priors)) {\n        lngths <- lapply(prs[(nam.prs <- names(priors))], length)\n        if (!is.list(priors) || !isTRUE(all.equal(lngths, lapply(priors, length)))) {\n            warning(\"'priors' is not a list with elements numeric vectors of appropriate \",\n                    \"length; default priors are used instead.\\n\")\n        } else {\n            prs[nam.prs] <- priors\n        }\n    }\n    # covariance matrices of parameters from separate fits\n    Covs <- list(betas = vcov(lmeObject), b = Cov.postRE, \n                 gammas = if (!is.null(W)) initSurv$cov.gammas, Bs.gammas = initSurv$cov.Bs.gammas,\n                 alphas = initSurv$cov.alphas, Dalphas = initSurv$cov.Dalphas)\n    # delete unused objects to free memory\n    namsDelObjs <- c(names(x), \"y.long\", \"Time\", \"event\", \"data.id2\", \"b\", \"D\", \"invD\", \"Cov.postRE\",\n                     \"id\", \"id.GK\", \"kn\", \"i\", \"K\", \"Z.i\")\n    if (param %in% c(\"td-value\", \"td-both\")) {\n        namsDelObjs <- c(namsDelObjs, \"mfX\", \"mfZ\", \"mfX.id\", \"mfZ.id\")\n    }\n    if (param %in% c(\"td-extra\", \"td-both\")) {\n        namsDelObjs <- c(namsDelObjs, \"mfX.extra\", \"mfZ.extra\", \"mfX.extra.id\", \"mfZ.extra.id\",\n                         \"Xextra\", \"Zextra\")\n    }    \n    rm(list = namsDelObjs); gc()\n    # joint model fit\n    model <- MCMCfit(y, x, param, extraForm, baseHaz, estimateWeightFun, initial.values, prs, \n                     scales, Funs, Covs, Data, con, df.RE)\n    names.betas <- names(fixef(lmeObject))\n    names.D <- colnames(getVarCov(lmeObject))\n    names.gammas <- names(coef(survObject))\n    names.Bs.gammas <- paste0(\"Bs.gammas\", seq_along(model$postMeans$Bs.gammas))\n    names.alphas <- if (param %in% c(\"td-value\", \"td-both\")) {\n        if ((na <- length(model$postMeans$alphas)) == 1) \"Assoct\" else {\n            nm <- colnames(transFun.value(1, data.id))\n            if (all(nm[-1] == \"\")) paste0(\"Assoct\", seq_len(na)) else c(\"Assoct\", paste0(\"Assoct:\", nm[-1]))\n        }\n    } else if (param %in% c(\"shared-betasRE\", \"shared-RE\")) {\n        paste0(\"Assoct:\", names.D)\n    }\n    names.Dalphas <- if (param %in% c(\"td-extra\", \"td-both\")) {\n        if ((nda <- length(model$postMeans$Dalphas)) == 1) \"AssoctE\" else {\n            nm <- colnames(transFun.extra(1, data.id))\n            if (all(nm[-1] == \"\")) paste0(\"AssoctE\", seq_len(nda)) else c(\"AssoctE\", paste0(\"AssoctE:\", nm[-1]))\n        }\n    }\n    model <- fixNames(model, names.betas, names.D, names.gammas, names.Bs.gammas, \n                      names.alphas, names.Dalphas, \n                      names.shapes = if (estimateWeightFun) \n                          paste0(\"shape\", seq_along(model$postMeans$shapes)),\n                      names.id = row.names(ranef(lmeObject)))\n    out <- c(model, list(x = x, y = y, Data = Data, Funs = Funs,\n                         Terms = list(termsYx = TermsX, termsYz = TermsZ, \n                                      termsT = survObject$terms,\n                                      termsYx.extra = if (param %in% c(\"td-extra\", \"td-both\")) TermsX.extra, \n                                      termsYz.extra = if (param %in% c(\"td-extra\", \"td-both\")) TermsZ.extra),\n                         Forms = list(formYx = formYx, formYz = formYz, \n                                      formT = formT, extraForm = extraForm),\n                         timeVar = timeVar, control = con, densLongCheck = densLongCheck,\n                         param = param, priors = prs, baseHaz = baseHaz, df.RE = df.RE, \n                         estimateWeightFun = estimateWeightFun,\n                         call = cl))\n    class(out) <- \"JMbayes\"\n    out\n}\n",
    "created" : 1442396464246.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2682550009",
    "id" : "35E63F9B",
    "lastKnownWriteTime" : 1443697395,
    "last_content_update" : 0,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/JMbayes/R/jointModelBayes.R",
    "project_path" : "R/jointModelBayes.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}